<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>操作系统产生死锁的原因和处理策略 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="操作系统产生死锁的原因和处理策略 " class="main-title"></div></div></header><article><div id="mWXrfWdetjA4ZhtKp97d" class="wolai-bookmark wolai-block"><a href="https://cloud.tencent.com/developer/article/1710895">操作系统产生死锁的原因和处理策略 - 腾讯云开发者社区-腾讯云</a><div class="info-box"><div class="text-pane"><div data-title="操作系统产生死锁的原因和处理策略 - 腾讯云开发者社区-腾讯云"></div><div data-desc="当进程需要以独占的方式访问资源时，可能会发生死锁（Deadlock）。死锁是指两个或以上进程因竞争临界资源而造成的一种僵局，即一个进程等待一个已经被占用且永不释..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://cloud.tencent.com/favicon.ico&quot;)"></div><div data-hostname="cloud.tencent.com"></div></div></div><div class="preview-pane"></div></div></div><h1 id="r1eawm9EHVV9KbqkWuiXYb" class="wolai-block"><span class="inline-wrap"><b>产生死锁的原因</b></span></h1><div id="d7nc8AasKfmLZ5V4N8Frcp" class="wolai-block wolai-text"><div><span class="inline-wrap">当进程需要以独占的方式访问资源时，可能会发生死锁（Deadlock）。死锁是指两个或以上进程因竞争临界资源而造成的一种僵局，即一个进程等待一个已经被占用且永不释放的资源。若无外力作用，这些进程都无法向前推进。</span></div></div><div id="sBR7iAKjzMXdm8e78xfvh6" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>产生死锁的根本原因</b></span><span class="inline-wrap">是系统能够提供的资源个数比要求该资源的进程数要少。</span></div></div><div id="9VNk5b8WN9e53TzGLWN23u" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>产生死锁的基本原因</b></span><span class="inline-wrap">可以分为两类：资源竞争和进程推进顺序不合理。</span></div></div><div id="kS2BARz7XYiDBZBmKR6BwD" class="wolai-block wolai-text"><div><span class="inline-wrap">在资源竞争场景下，系统所拥有的资源是有限的，不能满足每个进程的需要。</span></div></div><div id="gQkw4LeHL9jYbs8BkmbiN2" class="wolai-block wolai-text"><div><span class="inline-wrap">例子：</span></div></div><div id="pu9u5vU1JMni2UqZye6ALd" class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>有纸，B<span class="jill"></span>有笔</span></div></div><div id="mKCqroS1uRFyhxqPHR7SnJ" class="wolai-block wolai-text"><div><span class="inline-wrap">A：你不给我笔，我就写不了作业</span></div></div><div id="djPLExo1zTrJpEkKpbj8y6" class="wolai-block wolai-text"><div><span class="inline-wrap">B：你不给我纸，我就写不了作业</span></div></div><div id="m9iBjALSQUdjxGvVoEqabp" class="wolai-block wolai-text"><div><span class="inline-wrap">彼此僵持不下……</span></div></div><div id="8L5rBkPMcbvtegHVmTTpez" class="wolai-block wolai-text"><div><span class="inline-wrap">多个程序同时运行时，进程推进顺序不合理。</span></div></div><div id="2NXFozVZRbWYAG8BFb7wEE" class="wolai-block wolai-text"><div><span class="inline-wrap">例子：</span></div></div><div id="iuSxgFa8xcXBqNAvSXeSnT" class="wolai-block wolai-text"><div><span class="inline-wrap">A<span class="jill"></span>要前进<span class="jill"></span>2<span class="jill"></span>步，到桌子前，再后退<span class="jill"></span>2<span class="jill"></span>步。</span></div></div><div id="hyCiVAQJHm76TorhezMCZ4" class="wolai-block wolai-text"><div><span class="inline-wrap">但如果执行顺序不合理：A<span class="jill"></span>先后退，就永远到不了桌子前，触发不了后续动作，就会死锁。</span></div></div><h1 id="eYQGvwvjgMvM6xY1QSYTvb" class="wolai-block"><span class="inline-wrap"><b>产生死锁的必要条件</b></span></h1><h3 id="wM1TZ6SfdkamhhBT6CcwCU" class="wolai-block"><span class="inline-wrap"><b>产生死锁的四个必要条件：</b></span><span class="inline-wrap"> </span></h3><ul class="wolai-block"><li id="w7afENrcA2cqPkpykuBkjR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">互斥条件 涉及的资源是非共享的，即一次只能有一个进程使用。如果有另一个进程申请该资源，那么申请进程必须等待，直到该资源被释放。</span></li><li id="1JwhDYfrjxDGbu7oHDgjYc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">不剥夺条件（非抢占） 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自行释放。</span></li><li id="2PHjtRieD8ehnGimjWEYVg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">占有并等待（部分分配） 进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。</span></li><li id="8SzVn1rFP99BKR3c27F41P"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">环路条件（循环等待） 存在一种进程收尾相接的循环链，链中每个进程都在等待下一个进程所持有的资源，造成这组进程处于永远等待状态。</span></li></ul><div id="nfg7v1JponNZLvNkx6R27u" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>注意：</b></span><span class="inline-wrap"> 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立。反之，上述条件只要有一个不满足，就不会发生死锁。所以要避免发生死锁，只需要破坏其必要条件。</span></div></div><h1 id="6FPzJbA6D7JedoXCkp1Yj5" class="wolai-block"><span class="inline-wrap"><b>死锁的处理策略</b></span></h1><div id="1n7XZLFjBNk6j1puRJo36H" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>对于死锁一般有三种处理策略：预防死锁、避免死锁、死锁的检测及解除</b></span></div></div><h3 id="pnKAa3TDnHB8wf9WbMwmr2" class="wolai-block"><span class="inline-wrap"><b>预防死锁</b></span></h3><div id="aQgD4gJCkuoeX838Tkgwor" class="wolai-block wolai-text"><div><span class="inline-wrap">通过设置一些限制条件，破坏死锁的四个必要条件中的一个或几个，让死锁无法发生。</span></div></div><div id="uu1aZnK7nXvFijHVdiy1hn" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，将资源分层，得到上一层资源后才能够申请下一层资源，这样就破坏了环路等待条件。用户申请资源时，要求一次性申请所需要的全部资源，这就破坏了占有并等待条件。当一个已经占有某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经占有的所有资源，待以后需要时再重新申请，这就破坏了不剥夺条件。</span></div></div><div id="jyNxjht6qeDZewoB2xAQfb" class="wolai-block wolai-text"><div><span class="inline-wrap">这些预防死锁的方法破坏了系统的并行性和并发性，通常会降低系统的效率。</span></div></div><h3 id="vCgSzv8hR9XsejgJCtaFoJ" class="wolai-block"><span class="inline-wrap"><b>避免死锁</b></span></h3><div id="vPxUwxdGUXxgTEtemMRnrV" class="wolai-block wolai-text"><div><span class="inline-wrap">该方法同样属于事先预防，但它并不事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在动态分配资源的过程中，用一些算法来防止系统进入不安全状态，避免死锁的发生。</span></div></div><div id="po1ATkiCDwAxbmnhwooom4" class="wolai-block wolai-text"><div><span class="inline-wrap">具体策略如下：</span></div></div><div id="8AQNUcth2JZLFNmqDdXZEY" class="wolai-block wolai-text"><div><span class="inline-wrap">1\. 如果进程请求的资源会导致死锁，系统就拒绝启动该进程；</span></div></div><div id="1ArXKHVLaaACJcSK8rSYyK" class="wolai-block wolai-text"><div><span class="inline-wrap">2\. 如果对一个资源的分配会导致下一步的死锁，系统就拒绝本次分配；</span></div></div><div id="2FFK9CSELK3m9smUTFyCYT" class="wolai-block wolai-text"><div><span class="inline-wrap">显然要避免死锁，系统必须事先知道所拥有的资源数量及其属性。</span></div></div><div id="xfiFKuFidwH2PXReSzmuGQ" class="wolai-block wolai-text"><div><span class="inline-wrap">一个著名的避免死锁的算法是银行家算法。</span></div></div><div id="6shHQgkATd7bSUj7rzEnZq" class="wolai-block wolai-text"><div><span class="inline-wrap">银行家算法是<span class="jill"></span>DijkstraE W<span class="jill"></span>于<span class="jill"></span>1968<span class="jill"></span>年提出的。之所以称为银行家算法，是因为该算法可用于银行系统。</span></div></div><div id="vQPbrXc4DHiY9qqgB7Cky7" class="wolai-block wolai-text"><div><span class="inline-wrap">所谓银行家算法，是指分配资源之前先确定资源分配是否会造成系统死锁。如果会死锁，则不分配，只有确认不会死锁后才进行分配。</span></div></div><div id="6m7J5uvBRoTwfrXvfm2SJP" class="wolai-block wolai-text"><div><span class="inline-wrap">银行家算法，需要按如下原则判断是否分配资源：</span></div></div><ul class="wolai-block"><li id="1MZ6Zp3GJdFWv2zhE9x86Z"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">新进程进入系统时，它必须说明对各类资源的最大需求量，这一数量不能超过系统的资源总数。只有满足这一条件系统才接纳该进程。</span></li><li id="eRZvbPU66hVzfpxh8gpcYr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">当进程申请一组资源时，该算法需要检查进程对各类资源的最大需求量，如果系统现存的各类资源的数量可以满足此时的资源最大需求量时，就分配资源；否则进程必须等待，直到其他进程释放足够的资源为止。</span></li><li id="vtoDeG68YosJLRzpo3hZyM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程需要在一定时间内无条件地归还它所申请的全部资源。</span></li><li id="cQYbNAzgZiWMBbbuCPWdET"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>死锁的检测及解除</b></span><span class="inline-wrap"> 死锁预防和避免都是对资源分配进行适当限制，属于事前措施，并不利于系统资源的充分共享。而死锁检测不会试图阻止死锁，即在死锁发生前不会做任何操作，只是通过设置的检测机制，检测当前是否发生死锁。若发生死锁，则采取一些措施来解除死锁。 判断死锁的法则主要基于第四条死锁的必要条件：</span></li><li id="2UdENKS8ngNm93DrziCJiG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">资源分配路径中没有环路，则系统不会出现死锁</span></li><li id="obusvqyKhka9H4nGXJ9aG3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">资源分配路径中存在环路，则系统可能出现死锁</span></li><li id="axUV7ujU1uMXVqDUASFaws"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果环路中的每个资料类中都只有一个资源，则系统存在死锁</span></li><li id="2JNS1WgdZG6AAYL5Lv876k"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果环路中的每个资源类的资源个数不止一个，则环路的存在是产生死锁的必要条件但不是充分条件</span></li></ul><h3 id="yfSRRbTr3RRPikhTuHAmK" class="wolai-block"><span class="inline-wrap">解除死锁</span></h3><div id="w7DWCCN7eNZnzn4g5WZEpW" class="wolai-block wolai-text"><div><span class="inline-wrap">解除死锁的方法包括资源剥夺法、进程撤销法、进程回退法、系统重启法等：</span></div></div><ul class="wolai-block"><li id="wh2EXozHPB3MYcdvRAhCJq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">资源剥夺法</span></li></ul><div id="4t4Lu7DgPBcAZ42SyGMUiw" class="wolai-block wolai-text"><div><span class="inline-wrap">剥夺陷入死锁的进程所占用的资源，但并不撤销此进程，再将这些资源分配给需要的进程，直至死锁解除。</span></div></div><ul class="wolai-block"><li id="wrynFb1q2gsbJfYHy5x3BH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程撤销法</span></li><li id="6kNhhyHVXvGVnzcNYFMy6x"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">一次性撤销陷入死锁的所有进程，回收所有占用的资源，等死锁解除后，再重新运行进程。</span></li><li id="9HxjU4xMc8pNaHv1eAQqxF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">逐个撤销陷入死锁的进程，依次回收其资源并重新分配，直至死锁解除。可以优先撤销优先级低、预计剩余执行时间最长、CPU<span class="jill"></span>消耗时间少的进程。</span></li><li id="pFpfxnpRoieL9Q7jcebLmk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">进程回退法</span></li></ul><div id="i53FAoWLNoVXKUWtM8uy77" class="wolai-block wolai-text"><div><span class="inline-wrap">让所有的进程回退到系统保存的检查点，这种方法要求系统建立并保存检查点、建立回退机制。</span></div></div><ul class="wolai-block"><li id="v1etsAaqEwQSADkndT9Raj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">系统重启法 结束所有进程并重启系统。这种方法很简单，但损失很大，先前的工作可能都浪费了。</span></li></ul></article><footer></footer></body></html>