<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>操作系统之进程控制：进程的创建、终止、阻塞与唤醒、挂起与激活 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="操作系统之进程控制：进程的创建、终止、阻塞与唤醒、挂起与激活" class="main-title"></div></div></header><article><div id="2zymRuszMAXapLjbodLdUm" class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/lena7/article/details/119845079">操作系统之进程控制：进程的创建、终止、阻塞与唤醒、挂起与激活_唤醒一个进程时,操作系统干什么_lena7的博客-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="操作系统之进程控制：进程的创建、终止、阻塞与唤醒、挂起与激活_唤醒一个进程时,操作系统干什么_lena7的博客-CSDN博客"></div><div data-desc="进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。进程控制一般由OS的内核中的原语来实现的。操作系统内核OS内核：通常将一些与硬件紧密相关的模块（中断处理程序…）、各种常用设备的驱动程序以及运行频率较高的模块（时钟管理、进程调度…），都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为OS"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><div id="9Jup3DoyNmXHsKkhpUGbse" class="wolai-block wolai-text"><div><span class="inline-wrap">版权声明：本文为博主原创文章，遵循 </span><span class="inline-wrap"><a href="http://creativecommons.org/licenses/by-sa/4.0/"><span>CC 4.0 BY-SA</span></a></span><span class="inline-wrap"> 版权协议，转载请附上原文出处链接和本声明。</span></div></div><div id="nUZoXPVSmfAdTjgLLDpVws" class="wolai-block wolai-text"><div><span class="inline-wrap">进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。进程控制一般由<span class="jill"></span>OS<span class="jill"></span>的内核中的</span><span class="inline-wrap"><b>原语</b></span><span class="inline-wrap">来实现的。</span></div></div><h2 id="vegHPZD1AMBS4byemCXSwj" class="wolai-block"><span class="inline-wrap">操作系统内核</span></h2><div id="7fredkZwyDgoY3zpVG6Goi" class="wolai-block wolai-text"><div><span class="inline-wrap">OS<span class="jill"></span>内核：通常将一些与硬件紧密相关的模块（中断处理程序…）、各种常用设备的驱动程序以及运行频率较高的模块（时钟管理、进程调度…），都安排在紧靠硬件的软件层次中，将它们常驻</span><span class="inline-wrap"><a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020"><span>内存</span></a></span><span class="inline-wrap">，即通常被称为<span class="jill"></span>OS<span class="jill"></span>内核。这种安排方式的目的：①便于对这些软件进行保护，防止遭受其他应用程序的破坏。②提高<span class="jill"></span>OS<span class="jill"></span>运行效率。</span></div></div><div id="e581nwgo5Efkf93zFWbqD8" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>区分内核态和用户态的原因</b></span><span class="inline-wrap">：防止<span class="jill"></span>OS<span class="jill"></span>本身及关键数据（如<span class="jill"></span>PCB…）遭受到应用程序有意或无意的破坏。</span></div></div><ul class="wolai-block"><li id="6YsrdCeLyveJYxknCzkzPE"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">系统态：又称管态、内核态。具有较高的执行权限，能执行一切指令，访问所有寄存器和存储区，传统的<span class="jill"></span>OS<span class="jill"></span>都在系统态运行。</span></li><li id="quxnE6W1SvXEiQ5tpBqHZG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">用户态：又称目态。它是具有较低权限的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区。一般情况下，应用程序只能在用户态运行，不能执行<span class="jill"></span>OS<span class="jill"></span>指令以及访问<span class="jill"></span>OS<span class="jill"></span>区域，以防止应用程序对<span class="jill"></span>OS<span class="jill"></span>的破坏。</span></li></ul><h3 id="oqRNagrQALoT1y7WLYuZKi" class="wolai-block"><span class="inline-wrap">OS<span class="jill"></span>内核功能</span></h3><h4 id="1Xi6BxymEjS1cNxZxPWSQU" class="wolai-block"><span class="inline-wrap">支撑功能</span></h4><ol class="wolai-block"><li id="5zEu2DFyFLcaJStT3bmjSN"><div class="marker"></div><span class="inline-wrap">中断处理：是内核最基本的功能，是整个操作系统赖以活动的基础。如系统调用、键盘命令的输入、进程调度、设备驱动等，无不依赖于中断。</span></li><li id="dZhEBUxQQt9rbVPEsxj8pN"><div class="marker"></div><span class="inline-wrap">时钟管理：如时间片轮转调度，每当时间片用完，由时钟管理产生一个中断信号，促使调度程序重新进行调度；又比如在实时系统中的截止时间的控制；批处理系统中最长运行时间控制…</span></li><li id="nndAd8Tz3WVw6n1fa6rcbt"><div class="marker"></div><span class="inline-wrap">原语操作：由若干条命令组成，用于完成一定功能的一个过程。但它们是“</span><span class="inline-wrap"><b>原子操作</b></span><span class="inline-wrap">”，即要么全做，要么不做。原子操作在系统态下执行，常驻内存。</span></li></ol><h4 id="gQ3WpthiuAyuNZz4cMb4NE" class="wolai-block"><span class="inline-wrap">资源管理功能</span></h4><ol class="wolai-block"><li id="9P1zmSLRoQRso5zrNYc87V"><div class="marker"></div><span class="inline-wrap">进程管理</span></li><li id="apoYuynzJdPsp1YdxwpfZz"><div class="marker"></div><span class="inline-wrap">存储器管理</span></li><li id="jkUX6TFrLYPTL4Ut2HwvoS"><div class="marker"></div><span class="inline-wrap">设备管理</span></li></ol><ul class="wolai-block"><li id="x8vRthP3qVugy4a8docqzJ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">* *</span></li></ul><h2 id="5Y8AsLgwVeuqtnJHNkTcE2" class="wolai-block"><span class="inline-wrap">进程的创建</span></h2><h3 id="fqywq9gsVozMEZPUGtpVaN" class="wolai-block"><span class="inline-wrap">父子进程</span></h3><ul class="wolai-block"><li id="pyBuqAPzyc1tHsRYUJFTeh"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在<span class="jill"></span>OS<span class="jill"></span>中，允许一个进程创建另一个进程，创建者称为父进程，被创建者称为子进程，子进程也能创建更多孙进程。结构像</span><span class="inline-wrap"><b>树</b></span><span class="inline-wrap">一样。如在<span class="jill"></span>UNIX<span class="jill"></span>中，由父子进程组成一个进程组。</span></li><li id="cv2snFyZj4FPMQzVFvy9RB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">子进程可以继承父进程所拥有的的资源。当子进程被撤销时，应将从父进程那里获得的资源归还给父进程。此外，在撤销父进程的时候，也必须同时撤销其所有子进程。</span></li><li id="frPjyGH48JmREg58aBqFEu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">注意：</span><span class="inline-wrap"><b>在<span class="jill"></span>Windows<span class="jill"></span>中不存在任何进程层次结构</b></span><span class="inline-wrap">，所有进程具有相同的地位。但当进程创建了一个进程时，进程创建者会获得一个句柄（令牌），可以用来被控制被创建的进程，但是这个句柄是可以传递的。也就是说，获得了句柄的进程就拥有控制该进程的权利，因此进程之间不是层次关系，而是是否获得句柄，控制与被控制的关系。</span></li></ul><h3 id="sK9Ak7yHuJQvBLPXTD8aqw" class="wolai-block"><span class="inline-wrap">引进创建进程的典型事件</span></h3><ol class="wolai-block"><li id="bFGNy8tkqg4n8tpkxEoKDp"><div class="marker"></div><span class="inline-wrap">用户登录：在</span><span class="inline-wrap"><a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F/9706663?fr=aladdin"><span>分时系统</span></a></span><span class="inline-wrap">中，用户在终端键入登录命令后，若登录成功，系统将为该用户建立一个进程。</span></li><li id="r3kMpZpAn53c3rqxQwFqGN"><div class="marker"></div><span class="inline-wrap">作业调度：在</span><span class="inline-wrap"><a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span>多道批处理系统</span></a></span><span class="inline-wrap">中，当作业调度程序按一定算法调度到某些作业时，便将它们存入内存，为它们创建进程。</span></li><li id="ib2K6H8m49Pc44iHcPpaNX"><div class="marker"></div><span class="inline-wrap">提供服务：当运行中用户程序提出某种请求，系统将专门创建一个进程来提供用户所需要的服务，如需要打印文件时，创建打印进程。</span></li><li id="2JNfizU4NoZPzGecPCju6m"><div class="marker"></div><span class="inline-wrap">应用请求：用户进程自己创建新进程，与创建者进程以并发的形式完成特定任务。</span></li></ol><h3 id="wB2tvL1TpR4CrZgh7s66kK" class="wolai-block"><span class="inline-wrap">进程创建过程</span></h3><div id="cS3hynQK6fq5eqcZEXRsnT" class="wolai-block wolai-text"><div><span class="inline-wrap">OS<span class="jill"></span>调用进程创建原语<span class="jill"></span>Creat，该原语按照以下步骤创建一个新进程：</span></div></div><ol class="wolai-block"><li id="9UX3H9eNFza6r2Z3BXbJ71"><div class="marker"></div><span class="inline-wrap">申请空白<span class="jill"></span>PCB，为新进程从申请获得唯一的数字标识符。</span></li><li id="9FYZnhQyBXLwdaesnpo1rK"><div class="marker"></div><span class="inline-wrap">为新进程分配其运行所需资源，包括各种物理资源和逻辑资源，如<span class="jill"></span>CPU<span class="jill"></span>时间、所需内存大小、I/O<span class="jill"></span>设备等。</span></li><li id="3Y5nMYaooD3CKoT3HrevuY"><div class="marker"></div><span class="inline-wrap">初始化<span class="jill"></span>PCB：①初始化标识信息（数字标识符和父进程标识符）②初始化处理机状态（程序计数器指向程序入口地址，栈指针指向栈顶）③初始化处理机控制信息（设置进程状态、优先级等）</span></li><li id="ftqTKrPk7hjpivwo3DdsNd"><div class="marker"></div><span class="inline-wrap">如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</span></li></ol><ul class="wolai-block"><li id="1aM7cLy8p1GWYETzd87Wmn"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">* *</span></li></ul><h2 id="77PbzgLqzpvaz38DjbJFHk" class="wolai-block"><span class="inline-wrap">进程的终止</span></h2><h3 id="mkA1Hbn39zeAs49PEVMbuF" class="wolai-block"><span class="inline-wrap">引起进程终止的事件</span></h3><ol class="wolai-block"><li id="bYBpjJ4noGDqmFwX4sgUNG"><div class="marker"></div><span class="inline-wrap">正常结束：表示进程的任务已经完成，准备退出运行。在批处理系统中，通常会在程序的最后安排一条<span class="jill"></span>Halt<span class="jill"></span>指令，用于向<span class="jill"></span>OS<span class="jill"></span>表示运行已结束。</span></li><li id="gS1eeJFA9mVRQ2evj6ByC1"><div class="marker"></div><span class="inline-wrap">异常结束：指进程在运行时发生了某种异常事件，使程序无法继续运行。常见的有：  </span><div id="wihAEAFGTkiyy4uonvyFPq" class="wolai-block wolai-text"><div><span class="inline-wrap">① 越界：程序访问的存储区越出该进程的区域。  </span></div></div><div id="oXzDXEDLiaxDFeqWMatXnD" class="wolai-block wolai-text"><div><span class="inline-wrap">② 保护错：进程视图访问一个不存在或不允许访问的资源或文件。  </span></div></div><div id="6BhL5SrdWtYGx3DVUpsjkm" class="wolai-block wolai-text"><div><span class="inline-wrap">③ 非法指令：程序试图去执行一条不存在的指令。  </span></div></div><div id="bZqPfk8xYZ3FE5e2kJiTBd" class="wolai-block wolai-text"><div><span class="inline-wrap">④ 特权指令错：用户没有执行当前指令的权限。  </span></div></div><div id="3WX5RwpW89ha1pVjtTChiN" class="wolai-block wolai-text"><div><span class="inline-wrap">⑤ 运行超时：执行时间超过允许执行的最大值。  </span></div></div><div id="peuHhyxnZm8u9RS3wSNn2x" class="wolai-block wolai-text"><div><span class="inline-wrap">⑥ 等待超时：进程等待某事件的时间超过规定最大值。  </span></div></div><div id="d2gDZL4gKo45pLL1NbRZMD" class="wolai-block wolai-text"><div><span class="inline-wrap">⑦ 算术运算错：进程试图执行一个被进制的运算。  </span></div></div><div id="3xEoq7kh2H5dC96RqBSwba" class="wolai-block wolai-text"><div><span class="inline-wrap">⑧ I/O<span class="jill"></span>故障：在<span class="jill"></span>I/O<span class="jill"></span>过程发送了错误…</span></div></div></li><li id="63o7U1f5aJ7HfT3T6FPhoi"><div class="marker"></div><span class="inline-wrap">外界干预：指进程应外界的请求而终止运行。这些干预有：程序员或操作系统干预；父进程请求；父进程终止。</span></li></ol><h3 id="qjNhE2n237cdwuP6ccHS95" class="wolai-block"><span class="inline-wrap">进程终止过程</span></h3><div id="w8d5MuAffavXkyCDa1kqCL" class="wolai-block wolai-text"><div><span class="inline-wrap">OS<span class="jill"></span>调用进程终止原语，按下述过程终止指定的进程：</span></div></div><ol class="wolai-block"><li id="7PzVW9yY7HZsfZN9pMkXSn"><div class="marker"></div><span class="inline-wrap">根据被终止进程的标识符，从<span class="jill"></span>PCB<span class="jill"></span>集合中检索出该进程的<span class="jill"></span>PCB，读取进程的状态。</span></li><li id="sD94bUT7yTvFitpni28Hak"><div class="marker"></div><span class="inline-wrap">若进程处于执行状态，立即终止进程，并置调度标志位真，在进程终止后重新进程<span class="jill"></span>CPU<span class="jill"></span>调度。</span></li><li id="oH8scb9wxX4Q6CibqfvRDP"><div class="marker"></div><span class="inline-wrap">若进程还有子孙进程，将它们也终止，防止它们称为不可控的进程。</span></li><li id="6nbnE14dAiynuHMdgDoBw9"><div class="marker"></div><span class="inline-wrap">将终止进程所拥有的全部资源归还给父进程，或归还给系统。</span></li><li id="oe5AjZtsXcFEFy5SwRXPSe"><div class="marker"></div><span class="inline-wrap">将终止进程的<span class="jill"></span>PCB<span class="jill"></span>从所在队列中移除，操作系统记录等待需要搜集信息的其它程序搜集信息。</span></li></ol><ul class="wolai-block"><li id="8sruJpB14XjaXpqx6bBMC5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">* *</span></li></ul><h2 id="6zvSZBunP2h85fwrmxzPFd" class="wolai-block"><span class="inline-wrap">进程的阻塞与唤醒</span></h2><div id="syiMq9YDqpLeg6DnFmJNfw" class="wolai-block wolai-text"><div><span class="inline-wrap">在使用阻塞和唤醒时，必须成对使用，如果在某进程中引起了进程阻塞，那么与之合作的、或相关进程中必须安排一条该进程的唤醒原语，保证进程不会永久的处于阻塞状态，无法再运行。</span></div></div><h3 id="j2TYT8KuMgRmFEamwbg88q" class="wolai-block"><span class="inline-wrap">引起进程的阻塞与唤醒的事件</span></h3><ol class="wolai-block"><li id="hQa4NuqGPUF44TQYfofaj9"><div class="marker"></div><span class="inline-wrap">向系统请求共享资源失败，请求者进程只能被阻塞，只有在共享资源空闲时，才会被唤醒。</span></li><li id="4iuiuXXUCcdzHMcDoirL3o"><div class="marker"></div><span class="inline-wrap">等待某种操作的完成，在等待过程中应该是阻塞状态，等操作完成后，才会唤醒。</span></li><li id="gwsPVZqtdUPzkcvsmYoDrP"><div class="marker"></div><span class="inline-wrap">新数据尚未到达，进程只能阻塞，直到数据到达被唤醒。</span></li><li id="6FnLQk8ViRiinoNabkZWiv"><div class="marker"></div><span class="inline-wrap">等待新任务的到达，进程会阻塞，直到新任务到达会被唤醒，处理完成后又把自己阻塞起来。</span></li></ol><h3 id="85az3HpB2craWZK1DWHhNm" class="wolai-block"><span class="inline-wrap">进程阻塞过程</span></h3><div id="hRWhmHQqpimXpgHfgosuVi" class="wolai-block wolai-text"><div><span class="inline-wrap">当需要阻塞进程时，进程调用</span><span class="inline-wrap"><b>阻塞原语<span class="jill"></span>block</b></span><span class="inline-wrap">将自己阻塞，是一种主动行为。进入<span class="jill"></span>block<span class="jill"></span>状态后，进程先立即停止执行，然后将<span class="jill"></span>PCB<span class="jill"></span>的状态改为阻塞状态，并将<span class="jill"></span>PCB<span class="jill"></span>插入相应的阻塞队列。最后，重新进行<span class="jill"></span>CPU<span class="jill"></span>调度，切换前在<span class="jill"></span>PCB<span class="jill"></span>中保留当前进程的<span class="jill"></span>CPU<span class="jill"></span>状态，然后将<span class="jill"></span>CPU<span class="jill"></span>状态按新进程的<span class="jill"></span>PCB<span class="jill"></span>设置。</span></div></div><h3 id="82UJ7pNmDRVtDQBF8j57GX" class="wolai-block"><span class="inline-wrap">进程唤醒过程</span></h3><div id="xjSoRJKhVaKhfSZXp7uZnQ" class="wolai-block wolai-text"><div><span class="inline-wrap">当被阻塞进程所期待的事情发生，有关进程调用</span><span class="inline-wrap"><b>唤醒原语<span class="jill"></span>wakeup</b></span><span class="inline-wrap">将等待该事件的进程唤醒。执行过程：将阻塞进程从阻塞队列中移出，将其<span class="jill"></span>PCB<span class="jill"></span>的状态改为就绪状态，然后将<span class="jill"></span>PCB<span class="jill"></span>插入到就绪队列中。</span></div></div><ul class="wolai-block"><li id="dfzigKa5SEMHN6aisGgxkK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">* *</span></li></ul><h2 id="vKBpuqJr7PFRRgpK2nit5L" class="wolai-block"><span class="inline-wrap">进程的</span><span class="inline-wrap"><a href="https://so.csdn.net/so/search?q=%E6%8C%82%E8%B5%B7&amp;spm=1001.2101.3001.7020"><span>挂起</span></a></span><span class="inline-wrap">与激活</span></h2><h3 id="6gCs2L6LXkkL8AU5My7nvK" class="wolai-block"><span class="inline-wrap">进程的挂起</span></h3><div id="gjUrTafXCK7pHCJUcBpcjZ" class="wolai-block wolai-text"><div><span class="inline-wrap">当系统中出现了引起进程挂起的事件，OS<span class="jill"></span>利用</span><span class="inline-wrap"><b>挂起原语<span class="jill"></span>suspend</b></span><span class="inline-wrap">将指定进程或处于阻塞状态的进程挂起。执行过程：首先检查被挂起进程的状态，如果是就绪状态，就改为就绪挂起状态；如果是阻塞状态，就改为阻塞挂起状态；为了方便用户或父进程考查该进程的运行情况，把该进程的<span class="jill"></span>PCB<span class="jill"></span>复制到某指定的内存区域（一般挂起状态的进程存在于外存）。如果被挂起进程正在执行，就重新进行调度。</span></div></div><h3 id="vD6UZmvZXGkLoWVHa61tx3" class="wolai-block"><span class="inline-wrap">进程的激活</span></h3><div id="pMXux2a2M48jTuwmDzWsBM" class="wolai-block wolai-text"><div><span class="inline-wrap">当系统中发生激活进程的时间时，OS<span class="jill"></span>将利用</span><span class="inline-wrap"><b>激活原语<span class="jill"></span>active</b></span><span class="inline-wrap">将制定进程激活。激活过程：先将进程（PCB）从外存调入内存，检查该进程现在的状态，若是就绪挂起，则改为就绪状态；若是阻塞挂起，则改为钻丝状态。加入采用抢占式调度策略，则每当有就绪挂起状态的进程被激活，就要检查是否需要进行重新调度（如使用优先级的话，检查激活进程的优先级是否大于当前正在运行的进程，如果低则不用重新调度；如果高则剥夺当前进程的运行，把<span class="jill"></span>CPU<span class="jill"></span>分配给刚激活的进程）。</span></div></div><div id="fKmxpeiXnDRZh8jatA4cxs" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>