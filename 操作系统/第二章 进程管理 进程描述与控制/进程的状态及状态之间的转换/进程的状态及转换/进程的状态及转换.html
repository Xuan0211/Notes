<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>进程的状态及转换 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="进程的状态及转换" class="main-title"></div></div></header><article><div id="6qxcELt8RxWVcuG2SnouXx" class="wolai-bookmark wolai-block"><a href="https://www.orzzone.com/process-state-transition.html">进程的状态及转换</a><div class="info-box"><div class="text-pane"><div data-title="进程的状态及转换"></div><div data-desc="两状态进程模型是有先天缺陷的，在等待执行的进程队列中，有一些非运行状态的进程在等待CPU的执行；而另一些非运行状态的进程除等待CPU之外还需要等待I/O的完成，在I/O尚未完成之前，即使分派程序将CPU分派给它们，这些进程也无法执行（这些进程称为阻塞进程）。因此分派程序不能只是在进程队列中选择等待时间最长的进程，而是应扫描整个进程队列寻找未被阻塞且等待时间最长的进程。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://www.orzzone.com/favicon.ico&quot;)"></div><div data-hostname="www.orzzone.com"></div></div></div><div class="preview-pane" style="background-image: url(https://cdn.orzzone.com/five-process-state-transition.png)"></div></div></div><div id="fK9JU39frHdto6KWrVTXzi" class="wolai-block wolai-text"><div><span class="inline-wrap">2020-02-13 来源：《操作系统原理》 分类：</span><span class="inline-wrap"><a href="https://www.orzzone.com/operating-system"><span>操作系统原理</span></a></span><span class="inline-wrap"> 阅读(6873) 评论(0)</span></div></div><h2 id="4hi6rR16iFBzfUHQBD4KgJ" class="wolai-block"><span class="inline-wrap">一、两状态进程模型</span></h2><div id="8mJ4NqQKBgQUeDuYN4ALE2" class="wolai-block wolai-text"><div><span class="inline-wrap">最简单的进程运行模型是基于这样一个事实：进程要么正在执行，要么没有执行。这样，一个进程就有两种状态：</span></div></div><ol class="wolai-block"><li id="te9sZsmkV2wWdeY31MiTyg"><div class="marker"></div><span class="inline-wrap">运行（Running）；</span></li><li id="t2ytgzosmtoSHbVL5cFBUc"><div class="marker"></div><span class="inline-wrap">非运行（Not-running）。</span></li></ol><div id="unbBf43WRrw5iCqWZczUwo" class="wolai-block wolai-text"><div><span class="inline-wrap">当操作系统产生一个进程后，将该进程加入到非运行系统中，这样操作系统就知道该进程的存在，而该进程则等待机会执行。每隔一段时间，正在运行的进程就会被中断执行，此时分派程序将选择一个新进程投入运行（非运行状态的进程存放在一个排序队列中等待分派程序的调度运行），被中断运行的进程则由运行状态变为非运行状态，而投入运行的进程则由非运行状态变为运行状态。</span></div></div><h2 id="dEvLed5U3N753asqxXKFg9" class="wolai-block"><span class="inline-wrap">二、进程的三态模型</span></h2><div id="r4obWqzrqo13ngoXuwaXc4" class="wolai-block wolai-text"><div><span class="bg-fluorescent_yellow inline-wrap"><b>两状态进程模型是有先天缺陷的，在等待执行的进程队列中，有一些非运行状态的进程在等待<span class="jill"></span>CPU<span class="jill"></span>的执行；而另一些非运行状态的进程除等待<span class="jill"></span>CPU<span class="jill"></span>之外还需要等待<span class="jill"></span>I/O<span class="jill"></span>的完成，在<span class="jill"></span>I/O<span class="jill"></span>尚未完成之前，即使分派程序将<span class="jill"></span>CPU<span class="jill"></span>分派给它们，这些进程也无法执行（这些进程称为阻塞进程）。</b></span><span class="inline-wrap">因此分派程序不能只是在进程队列中选择等待时间最长的进程，而是应扫描整个进程队列寻找未被阻塞且等待时间最长的进程。</span></div></div><div id="wRoGi9NgnFZH4U4gvxmafL" class="wolai-block wolai-text"><div><span class="inline-wrap">因此，将非运行状态分成就绪（Ready）和阻塞（Blocked）两种状态。这样，运行中的进程就有了三种基本状态：运行、阻塞和就绪。这三种状态构成了最简单的进程生命周期。</span></div></div><ol class="wolai-block"><li id="fpGc67PGiN5Dn9zakbAUGR"><div class="marker"></div><span class="inline-wrap">运行状态。进程获得了<span class="jill"></span>CPU<span class="jill"></span>和其他所需要的资源，目前正在<span class="jill"></span>CPU<span class="jill"></span>上运行。对单<span class="jill"></span>CPU<span class="jill"></span>系统而言，只能有一个进程处于运行状态。</span></li><li id="2MQLN5MNFtbfVHArYhqkqG"><div class="marker"></div><span class="inline-wrap">阻塞状态。进程运行中发生了某种等待事件（如发生了等待<span class="jill"></span>I/O<span class="jill"></span>的操作）而暂时不能运行的状态。处于该状态的进程不能去竞争<span class="jill"></span>CPU，因为此时即使把<span class="jill"></span>CPU<span class="jill"></span>分配给它也无法运行。处于阻塞状态的进程可以有多个。</span></li><li id="pCrqEk5GajoNPMUXW6Dbi2"><div class="marker"></div><span class="inline-wrap">就绪状态。进程获得了除<span class="jill"></span>CPU<span class="jill"></span>之外的所需资源，一旦得到<span class="jill"></span>CPU<span class="jill"></span>就可以立即投入运行。不能运行的原因还是因为<span class="jill"></span>CPU<span class="jill"></span>资源太少，只能等待分配<span class="jill"></span>CPU<span class="jill"></span>资源。在系统中出于就绪状态的进程可能有多个，通常是将它们组成一个进程就绪队列。</span></li></ol><div id="ksFS79Zx6hSu6YciWNfmon" class="wolai-block wolai-text"><div><span class="inline-wrap">这三种进程状态的变迁应注意以下<span class="jill"></span>5<span class="jill"></span>点：</span></div></div><ol class="wolai-block"><li id="hVE5DhFjYCyBqhSRabmtxN"><div class="marker"></div><span class="inline-wrap">进程由就绪状态变迁到运行状态是由进程调度程序（分派程序）完成的。也就是说，一旦<span class="jill"></span>CPU<span class="jill"></span>空闲，进程调度程序就会立即依据某种调度算法从进程就绪队列中选择一个进程占用<span class="jill"></span>CPU<span class="jill"></span>运行。</span></li><li id="kxcN95bZamJyxpbWHDSfnU"><div class="marker"></div><span class="inline-wrap"><b>进程由运行状态变迁到阻塞状态，通常是由运行程序自身提出的。</b></span></li><li id="ej6bh1RLaayy5zdqxVGSKR"><div class="marker"></div><span class="inline-wrap">进程由阻塞状态变迁为就绪状态总是由外界事件引起的。通常是当阻塞状态进程被阻塞的原因得到解除时（等待事件已完成），由当前正在运行的进程来响应这个外界事件的请求，唤醒相应的阻塞状态进程，将其转换为就绪状态并插入到进程就绪队列中，然后改运行进程继续完成自身的任务。</span></li><li id="wEJq9TYPtCqwZGSWJBrwT6"><div class="marker"></div><span class="inline-wrap">进程由运行状态变迁为就绪状态通常在分时操作系统中出现，即系统分配给运行进程所使用的<span class="jill"></span>CPU<span class="jill"></span>时间片用完，这时进程调度程序将<span class="jill"></span>CPU<span class="jill"></span>轮转给下一个就绪进程使用，由于被取消<span class="jill"></span>CPU<span class="jill"></span>使用权的进程仅仅是没有了<span class="jill"></span>CPU，而其他所需资源并不缺少，即满足就绪状态的条件，因此转为就绪状态并插入到进程就绪队列中。</span></li><li id="3bk1d5aGPj6Ndq7Ku8JXRi"><div class="marker"></div><span class="inline-wrap"><b>进程不能有阻塞状态直接变迁到运行状态。</b></span></li></ol><div id="uV2WSTFQVBPc8LZ8UXcKzm" class="wolai-block wolai-text"><div><span class="inline-wrap">此外还要注意的是，虽然进程有三个基本状态，但对每个进程而言，其生命周期内不一定都要经历这三个状态。对于一些计算性的简单进程，运行很短的时间就结束了，也就无须进入阻塞状态了，所以个别进程可以不经历阻塞状态。</span></div></div><h2 id="4TLYqoTHQLzpFyh17bqDdm" class="wolai-block"><span class="inline-wrap">三、进程的五态模型（five-state process model）</span></h2><h3 id="kTeakr6SuWWRm7A2j9WSma" class="wolai-block"><span class="inline-wrap">1、进程的产生</span></h3><div id="kKw9b4zgKut4ttdeLuTRjf" class="wolai-block wolai-text"><div><span class="inline-wrap">当需要创建一个新进程时，系统为该进程分配一个进程控制块（PCB），并为该进程分配内存空间，且装入该进程对应的程序和有关数据。这时，一个新进程就产生了。</span></div></div><div id="1nC2MgMVbovMPs6UKidKeb" class="wolai-block wolai-text"><div><span class="inline-wrap">通常有<span class="jill"></span>4<span class="jill"></span>中事件会导致新进程的产生：</span></div><div id="umUwTGu51bp5YkttNvNFLR" class="wolai-block wolai-text"><div><span class="inline-wrap">①在一个批处理环境中，为了响应一个任务的要求而产生进程。</span></div></div><div id="ifzirj6Qcd6rCKng5YRwDr" class="wolai-block wolai-text"><div><span class="inline-wrap">②在一个交互式环境中（如分时操作系统），当一个新用户企图登录时会产生进程。在这两种情况下，进程的产生均由操作系统负责。</span></div></div><div id="cqftnBrdVVY5ugqLnJuNYM" class="wolai-block wolai-text"><div><span class="inline-wrap">③操作系统代替用户程序产生进程。例如，如果用户想要打印文件，操作系统就产生一个打印进程来对打印进行管理。</span></div></div><div id="whVauHj9aNQzw56csts6p3" class="wolai-block wolai-text"><div><span class="inline-wrap">④由用户程序来产生多个进程。</span></div></div></div><div id="m1PTnx5cbBLHtUwouLitX7" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个进程产生另一个进程时，生成进程称为父进程，而被生成进程称为子进程。通常情况下，这些相关进程需要相互通信并且相互协作。</span></div></div><h3 id="oMSiWVfe2UA42aPSQJtT9K" class="wolai-block"><span class="inline-wrap">2、进程的终止</span></h3><div id="6kE24kcEmPUSoYgbdujkQA" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个进程执行到自然结束点，或出现不可克服的错误而不得不取消时，或被拥有特定权限的进程取消时，该进程被终止，其状态转换为终止状态。处于终止状态的进程不能再被调度执行，与其相关的数据信息由操作系统临时保存。终止一个进程时，系统需要逐步释放为其分配的系统资源，最后释放其<span class="jill"></span>PCB。这时，系统将该进程的状态设为终止态，以方便进行相应的收尾工作。</span></div></div><h3 id="1LFm5muPbryojSuvxrMjeB" class="wolai-block"><span class="inline-wrap">3、五态模型</span></h3><div id="99cBNkG7Hnqz4t2tgseUkE" class="wolai-block wolai-text"><div><span class="inline-wrap">引入了创建状态和终止状态后，系统又增加了三个新的进程状态变迁。</span></div></div><ol class="wolai-block"><li id="wDHdf3KQFeqMM5UfEDfr18"><div class="marker"></div><span class="inline-wrap">由空到创建状态。</span></li><li id="oj6fYViRME3HCQXQsfivpS"><div class="marker"></div><span class="inline-wrap">由创建状态边签到就绪状态。</span></li><li id="bHvsXuSgR3zWpGktGuypmY"><div class="marker"></div><span class="inline-wrap">运行状态变迁到终止状态。</span></li></ol><div id="gH2hMKoTr467uUnBskejFd" class="wolai-block wolai-text"><div><span class="inline-wrap">五态模型图：</span></div></div><div id="8ipEyB4yAx2Mza4RQDqh9p" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://cdn.orzzone.com/five-process-state-transition.png" style="width: 993.6px"/></figure></div><div id="xm7eGeLm7FUbbKUGJoenxX" class="wolai-block wolai-text"><div><span class="inline-wrap">五态模型（A five-state process model）的介绍用英文解释非常清晰：</span></div></div><ol class="wolai-block"><li id="9hVsVA9kNRT8CeWRqPuxZT"><div class="marker"></div><span class="inline-wrap">New : A process has been created but has not yet been admitted to the pool of executable processes.</span></li><li id="u2sNQrSvWtwp8xJSR8YdAx"><div class="marker"></div><span class="inline-wrap">Ready : Processes that are prepared to run if given an opportunity. That is, they are not waiting on anything except the CPU availability.</span></li><li id="8TBmd8tUYz12JSFirLYqsy"><div class="marker"></div><span class="inline-wrap">Running: The process that is currently being executed. (Assume single processor for simplicity.)</span></li><li id="cDNHePdbhpP7X7755pmRhA"><div class="marker"></div><span class="inline-wrap">Blocked : A process that cannot execute until a specified event such as an IO completion occurs.</span></li><li id="mYUBnr5Hy59f4zpWahZrG3"><div class="marker"></div><span class="inline-wrap">Exit: A process that has been released by OS either after normal termination or after abnormal termination (error).</span></li></ol><h2 id="7Bq3TfW9PS31DzkV86yd2b" class="wolai-block"><span class="inline-wrap">四、进程的挂起（process suspension）</span></h2><h3 id="c8hLkW6yPdYZU7JBueJbR3" class="wolai-block"><span class="inline-wrap">1、挂起状态的引入</span></h3><div id="uAbLux3oJTEG2M3sJmXc46" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>前面讨论的五状态进程模型中，新创建的进程一旦被系统接纳就一直存在于内存中，直到被终止。在这种情况下，一方面随着系统中进程数量的不断增多，系统内存资源会变得越来越紧张；另一方面，由于<span class="jill"></span>CPU<span class="jill"></span>的速度远远高于<span class="jill"></span>I/O<span class="jill"></span>的速度，这使得内存中经常会出现大部分进程都在等待<span class="jill"></span>I/O<span class="jill"></span>操作而<span class="jill"></span>CPU<span class="jill"></span>缺空闲的现象。当内存中没有就绪进程时，为了减少<span class="jill"></span>CPU<span class="jill"></span>的空闲时间，可以采用交换技术将内存中暂时不能运行的某些进程挂起，释放其所占用的内存资源，以便重新接纳一个新进程或外存上已具备运行条件的进程进入内存的进程就绪队列。进程挂起（也称换出）是指在内存中的进程被暂时移出保存到外存中（如磁盘）的过程。当某个进程被挂起时，若被挂起的进程处于运行状态则停止执行；若被挂起的进程处于就绪状态则暂时不参加进程调度。引起进程挂起的原因大致有以下三种：</b></span></div></div><ol class="wolai-block"><li id="tnD9R6p8fJvQNnJN2fLCXS"><div class="marker"></div><span class="inline-wrap">用户的请求。</span></li><li id="bG33TR33KvHhDTF4iaaKFH"><div class="marker"></div><span class="inline-wrap">父进程的请求。</span></li><li id="njy1zoErSpg1WnFRzCRiD7"><div class="marker"></div><span class="inline-wrap">操作系统的原因。操作系统引起的挂起可分为以下三种：</span><ol class="wolai-block"><li id="xiHDvECwunB13gM771dQTd"><div class="marker"></div><span class="inline-wrap">交换。当操作系统发现系统的内存资源已经不能满足运行进程的需要时，可以将当前不重要的进程挂起，以达到平衡系统负载的目的。</span></li><li id="pGyRJev2CdvWzhHNWufR8S"><div class="marker"></div><span class="inline-wrap">出现问题或故障时。当系统出现故障时，操作系统会暂时将系统中涉及该故障的进程挂起（换出），等故障恢复后，再将这些进程恢复到挂起前的状态（换入，由外存调入到内存）。</span></li><li id="i8jcdqJSTfwpzRVqVachi7"><div class="marker"></div><span class="inline-wrap"><b>操作系统的需要。为监视系统的活动，操作系统可以挂起和激活（将外存中的进程调入到内存）一些记录系统资源使用状况的进程和用户进程活动的记账进程。</b></span></li></ol></li></ol><h3 id="oPoqFGWbpiJwdSp71dJrMJ" class="wolai-block"><span class="inline-wrap">2、具有挂起状态的进程状态转换</span></h3><div id="aKAn8CcZdamTkr2xZ55Hzu" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="http://www.orzzone.com/wp-content/uploads/states_modified.png" style="width: 684.8px"/></figure></div><div id="4yUV5QEJCMoJQrT1imw92B" class="wolai-block wolai-text"><div><span class="inline-wrap">引入挂起状态后，需要实现进程在挂起（即在外存）状态和非挂起（即在内存）状态之间的转换。由于被挂起的进程不能被调度运行，因此通常将挂起状态称为静止状态，而将非挂起状态称为活跃状态。根据挂起前进程所处的状态，可以将挂起状态分为：静止就绪状态和静止阻塞状态。系统通常将具有相同状态的进程组成一个或多个队列。为了区别，将进程基本状态中的就绪状态改称为活动就绪状态，阻塞状态改称为活动阻塞状态。相应地，我们又多了<span class="jill"></span>6<span class="jill"></span>中转换关系：</span></div></div><ol class="wolai-block"><li id="aEveaaqNaFP2JQ3s1RfZJJ"><div class="marker"></div><span class="inline-wrap">活动阻塞状态挂起变为静止阻塞态。主要有两种情况会发生这种挂起（进程由内存换出至外存）状态变化：①若当前不存在活动就绪进程，则至少有一个活动阻塞进程由内存兑换至外存成为静止阻塞进程，以腾出内存空间，从外存调入一个静止就绪进程使其变为活动就绪进程（保证内存中至少有一个活动就绪进程，可供进程调度程序调度运行以免<span class="jill"></span>CPU<span class="jill"></span>空闲）；②操作系统根据当前的资源状态和性能要求，可以将某些活动阻塞进程换出至外存成为静止阻塞进程。</span></li><li id="xm2dDQPSe1jYzac4kj5UrD"><div class="marker"></div><span class="inline-wrap">静止阻塞态激活变为活动阻塞态。一般在满足两个条件下，系统可以激活（进程由外存换入至内存）一个静止阻塞态进程，使之成为活动阻塞进程。即：①操作系统已经得知导致该进程阻塞的事件即将结束；②内存中已经有了一大块空闲的空间。</span></li><li id="9qjfaH9uVg4cyhpygFBEri"><div class="marker"></div><span class="inline-wrap">静止阻塞态变为静止就绪态。当在外存上的静止阻塞进程所需资源得到满足或者等待的事件已经完成时，该进程由静止阻塞态变为静止就绪态（但仍然在外存）。</span></li><li id="wnqUX5ugzKhCLPUSqeBKFB"><div class="marker"></div><span class="inline-wrap">静止就绪态激活变为活动就绪态。主要有三种情况会发生这种激活（进程由外存换入至内存）状态变化：①外存上的静止就绪进程具有比内存中的活动就绪进程更高的优先级；②内存中已经有了一大块空闲的空间；③当前内存中没有活动就绪进程。</span></li><li id="8844RkMnqk8KPyox7vEHxM"><div class="marker"></div><span class="inline-wrap">活动就绪态挂起变为静止就绪态。这种状态变化主要是由于系统调节负荷（即内存紧张）的需要，或者是系统优化性能的需求，而将某些目前暂不需要运行的活动就绪进程由内存换出至外存。</span></li><li id="xuAEtoxY5fLamAKsFRJMQP"><div class="marker"></div><span class="inline-wrap">运行态挂起（由内存换出至外存）变为静止就绪态。这种状态变化制药是运行进程出现了错误或异常，或者是对运行进程进行分析的需要。</span></li></ol><div id="s1mMBWQVox4mV3Hi5sqdrW" class="wolai-block wolai-text"><div><span class="inline-wrap">可见，只有处于活动就绪态的进程，才能参与进程调度得到<span class="jill"></span>CPU，并在获得<span class="jill"></span>CPU<span class="jill"></span>后立即投入运行。具有挂起状态的系统虽然提高了内存的利用率，但同时也使管理更加复杂，且增加了系统的开销。</span></div></div><h2 id="gk2Zcg3wsdY6mbyEvwWzB7" class="wolai-block"><span class="inline-wrap">五、进程控制块</span></h2><h3 id="aakPKghKUay8xe9zF6yuuY" class="wolai-block"><span class="inline-wrap">1、进程控制块产生的原因</span></h3><div id="wtQt8MCKCWvuncf8iNiDBS" class="wolai-block wolai-text"><div><span class="inline-wrap">操作系统需要为进程定义一种能够描述和控制进程运行的数据结构，这就是进程控制块（PCB）。即<span class="jill"></span>PCB<span class="jill"></span>是操作系统中最重要的数据结构之一，因为它是进程存在的唯一标志。PCB<span class="jill"></span>中存放着操作系统所需的用于描述进程当前情况的全部描述信息，以及控制进程运行的全部控制信息和相关的资源信息。在几乎所有的多道程序操作系统中，进程的<span class="jill"></span>PCB<span class="jill"></span>都是全部或部分常驻内存，操作系统通过<span class="jill"></span>PCB<span class="jill"></span>而感知进程的存在，并且根据<span class="jill"></span>PCB<span class="jill"></span>对进程实施控制和管理。</span></div></div><h3 id="aeKGH1yLthxdEeCZ9QoFNn" class="wolai-block"><span class="inline-wrap">2、进程控制块中的信息</span></h3><div id="g3knFRwmzygNvaAf1oNMDa" class="wolai-block wolai-text"><div><span class="inline-wrap">不同操作系统对进程的管理和控制机制是不同的，因此不同系统中<span class="jill"></span>PCB<span class="jill"></span>中信息的多少也不同，但多数系统中的<span class="jill"></span>PCB<span class="jill"></span>都包含以下信息。</span></div></div><ol class="wolai-block"><li id="rWrPSyNM64p81Tejq5hnHh"><div class="marker"></div><span class="inline-wrap"><b>进程标识符。每个进程都必须有唯一的进程标识符，也称进程的内部名。</b></span></li><li id="dXAABnF8FRgvBF3yBb2Mue"><div class="marker"></div><span class="inline-wrap"><b>进程的当前状态。它表明进程当前所处的状态，并作为进程调度程序分配<span class="jill"></span>CPU<span class="jill"></span>的依据，仅当进程处于就绪状态时才可以被调度执行。若进程处于阻塞状态，还需要在<span class="jill"></span>PCB<span class="jill"></span>中记录阻塞的原因，以供唤醒原语唤醒进程时使用。</b></span></li><li id="1SmCWRjHNboKN4vMDJxi3E"><div class="marker"></div><span class="inline-wrap"><b>进程中的程序段与数据段地址。</b></span></li><li id="sQHCVtxPMEyhUyNP45FGbG"><div class="marker"></div><span class="inline-wrap">进程资源清单。</span></li><li id="pR2R9vdUMNGCHCAoMD6zsh"><div class="marker"></div><span class="inline-wrap">进程优先级。</span></li><li id="bjHCSafnRHPmmY1oFGUQEX"><div class="marker"></div><span class="inline-wrap"><b>CPU<span class="jill"></span>现场保护区。</b></span></li><li id="6vEj7ZmCHrg8S1YFiXNXDX"><div class="marker"></div><span class="inline-wrap"><b>进程同步与通信机制。</b></span></li><li id="2E2jMwM3RwyVAXmPS4iYUF"><div class="marker"></div><span class="inline-wrap">PCB<span class="jill"></span>队列指针或链接字。用于将处于同一个状态的进程连接成一个队列，链接字中存放该进程所在队列中的下一个进程<span class="jill"></span>PCB<span class="jill"></span>的首地址。</span></li><li id="jGY32Vo3yQ3JRJqvxBXqQE"><div class="marker"></div><span class="inline-wrap">与进程相关的其他信息。</span></li></ol><h3 id="irTzhjrs2BQNjoBUS1Eup6" class="wolai-block"><span class="inline-wrap">3、进程控制块的组织方式</span></h3><div id="75omcf3VUfZL5qgVKbZVaV" class="wolai-block wolai-text"><div><span class="inline-wrap">在一个系统中，通常可能有多个进程同时存在，所以就拥有多个<span class="jill"></span>PCB。为了能对<span class="jill"></span>PCB<span class="jill"></span>进行有效的管理和调度，就要用适当的方法把这些<span class="jill"></span>PCB<span class="jill"></span>组织起来。目前常用的<span class="jill"></span>PCB<span class="jill"></span>组织方式有以下三种。</span></div></div><ol class="wolai-block"><li id="fhvtqD1pzubygAndumZyNw"><div class="marker"></div><span class="inline-wrap">线性表方式。论进程的状态如何，将所有的<span class="jill"></span>PCB<span class="jill"></span>连续地存放在内存的系统区（内核空间），这种方式适用于系统中进程数目不多的情况。</span></li><li id="aaUb6Z8dM6i5j6DsrMfDFC"><div class="marker"></div><span class="inline-wrap">链接表方式。系统按照进程的状态将进程的<span class="jill"></span>PCB<span class="jill"></span>链成队列，从而形成进程就绪队列、进程阻塞队列、进程运行队列等（单<span class="jill"></span>CPU<span class="jill"></span>系统进程运行队列仅有一个<span class="jill"></span>PCB）。链接表方式组织<span class="jill"></span>PCB<span class="jill"></span>可以很方便地对同类<span class="jill"></span>PCB<span class="jill"></span>进行管理，操作简单，但是要查找某个进程的<span class="jill"></span>PCB<span class="jill"></span>就比较麻烦，因此只适用于小系统中进程数比较少的情况。</span></li><li id="jJxTaq6FouQjGp8fKZGjRb"><div class="marker"></div><span class="inline-wrap">索引表方式。系统按照进程的状态分别建立就绪索引表、阻塞索引表等，通过索引表来管理系统中的进程。索引表方式组织<span class="jill"></span>PCB<span class="jill"></span>可以很方便地查找到某个进程的<span class="jill"></span>PCB，因此适用于进程数较多的情况，但是索引表需要占用一定的内存空间。</span></li></ol><div id="rWz9mjvikG7RcqCk8DwZ1V" class="wolai-block wolai-text"><div><span class="inline-wrap">由于操作系统是根据<span class="jill"></span>PCB<span class="jill"></span>对进程实施控制和管理的，因此进程状态的变迁也是根据<span class="jill"></span>PCB<span class="jill"></span>中的状态信息来实现的。</span></div></div><div id="dv8Lgu3SYAqzaSMo5nywHJ" class="wolai-block wolai-text"><div><span class="inline-wrap">文章名称：《进程的状态及转换》文章链接：</span><span class="inline-wrap"><a href="https://www.orzzone.com/process-state-transition.html"><span>https://www.orzzone.com/process-state-transition.html</span></a></span><span class="inline-wrap">商业联系：yakima.public@gmail.com</span></div></div><div id="aLSUfU2YRpDvtqoeV7vTPK" class="wolai-block wolai-text"><div><span class="inline-wrap">本站大部分文章为原创或编译而来，对于本站版权文章，未经许可不得用于商业目的，非商业性转载请以链接形式标注原文出处。  
本站内容仅供个人学习交流，不做为任何投资、建议的参考依据，因此产生的问题需自行承担。</span></div></div><h4 id="7ZTxWinrQQouRyLECPiUFH" class="wolai-block"><span class="inline-wrap"><a href="https://www.orzzone.com/author/yakima"><span>Yakima Teng</span></a></span></h4><div id="qVd2xj8xgoqk7w8WFjavfm" class="wolai-block wolai-text"><div><span class="inline-wrap">关于作者：楠溪江人，出生于<span class="jill"></span>1991<span class="jill"></span>年，目前坐标上海。读书时代跳过级、保过送，工作后转过行。2013<span class="jill"></span>年本科毕业于北药。看书、码字、敲代码、打羽毛球是我花时间的爱好。曾在某上市药企任国际药品注册岗，现在某高新企业任前端管理岗。</span></div></div></article><footer></footer></body></html>