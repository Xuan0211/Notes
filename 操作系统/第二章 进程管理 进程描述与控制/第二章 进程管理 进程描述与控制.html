<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>第二章 进程管理 进程描述与控制 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="第二章 进程管理 进程描述与控制" class="main-title"></div></div></header><article><h1 id="vjC6aLWKdwam5b2dfEC9W9" class="wolai-block"><span class="inline-wrap">进程管理的目的、内容</span></h1><h2 id="ovoAtMdZGxbc2Y6U2dPnua" class="wolai-block"><span class="inline-wrap">目的</span></h2><div id="ofs6dsp6HodeXHa2yv3bjZ" class="wolai-block wolai-text"><div><span class="inline-wrap">有效提高计算机资源<span class="jill"></span>CPU<span class="jill"></span>的利用率</span></div></div><h2 id="cgPwYPbE5HXtZPYg6jCzQ" class="wolai-block"><span class="inline-wrap">内容</span></h2><div id="stjCo1hQWKXYibDPS6fM4m" class="wolai-block wolai-text"><div><span class="inline-wrap">进程控制、进程调度</span></div></div><div id="exeWvPAwx242xzvzYV36YM" class="wolai-block wolai-text"><div><span class="inline-wrap">进程同步 死锁处理</span></div></div><div id="jDKUCo1piM9zzK1QYFWtvN" class="wolai-block wolai-text"><div><span class="inline-wrap">进程通信</span></div></div><div id="qxcrP2k2hzJKoLJbHwgwGt" class="wolai-bookmark wolai-block"><a href="https://blog.51cto.com/u_15178976/3701790?articleABtest=0">操作系统（二）—— 进程管理（1）：进程_51CTO博客_操作系统 进程调度</a><div class="info-box"><div class="text-pane"><div data-title="操作系统（二）—— 进程管理（1）：进程_51CTO博客_操作系统 进程调度"></div><div data-desc="操作系统（二）—— 进程管理（1）：进程，1.进程1.1进程概念1.1.1进程1.1.2进程状态1.1.3进程控制块1.1.4线程1.2进程调度1.2.1调度队列1.2.2调度程序1.2.3上下文切换1.3进程运行1.3.1进程创建1.3.2进程终止1.4进程间通信1.4.1共享内存系统1.4.2消息传递系统1.6客户机/服务器通信1.6.1套接字1.6.2远程过程调用1.6.3管道  早期的计算"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://blog.51cto.com/favicon.ico&quot;)"></div><div data-hostname="blog.51cto.com"></div></div></div><div class="preview-pane"></div></div></div><h1 id="7sJmuHr5Qeo8JXZ9v5L4xT" class="wolai-block"><span class="inline-wrap">进程的概念</span></h1><div id="9HBhzVCBs3sZ53tJ2cQe9P" class="wolai-row"><div id="xvGQhXxu6siSe79wJXhz5" class="wolai-col" style="flex-grow: 0.7708333333333334"><blockquote id="mT6T9NU2RtePNdPkHtae71" class="wolai-block"><span class="inline-wrap">在多道程序环境下，</span><span class="inline-wrap"><a href="%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F.html#5knBJXfsrPMKtsoF5j3w24" class="wolai-bi-link"><span class="embed-page">多道程序系统</span></a></span><span class="inline-wrap">并发执行，</span><span class="inline-wrap">并发执行可提高系统资源利用率，但程序并发执行的结果是使得程序执行具有以下特征：</span><ol class="wolai-block"><li id="iioC1Tw79xRwKPF9ynnUML"><div class="marker"></div><span class="inline-wrap">间断（异步）性</span></li><li id="9kv4b5jWn6wrDpR8RqxjJV"><div class="marker"></div><span class="inline-wrap">失去封闭（共享）性</span></li><li id="8ydRDzeuZrHdEXbVLdGHs1"><div class="marker"></div><span class="inline-wrap">失去可再现性</span></li></ol><div id="pCwaaAY1WEksJ9DYuuNNJW" class="bg-blond wolai-block wolai-text"><div><span class="inline-wrap"><b>异步和共享是我们所需要的，但不可再现不是我们所希望的.</b></span></div></div></blockquote></div><div id="6r9D8gGntKBKeRfiPhdtWd" class="wolai-col" style="flex-grow: 0.22916666666666666"><div id="p2jabBW2btDGwo99LEypPh" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%8D%95%E9%81%93%E7%B3%BB%E7%BB%9F/%E5%8D%95%E9%81%93%E7%B3%BB%E7%BB%9F.html"><span>单道系统</span></a></div><div id="5knBJXfsrPMKtsoF5j3w24" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F.html"><span>多道程序系统</span></a></div><div id="gBoScfUTnfrim3qvd4XYwY" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%B9%B6%E5%8F%91%E6%80%A7/%E5%B9%B6%E5%8F%91%E6%80%A7.html"><span>并发性</span></a></div><div id="kc1qHNMKrA37b1ANkWsLHH" class="wolai-block wolai-text"><div></div></div></div></div><aside id="hDZ6VT52L14szQjEUPknVK" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">进程有两个基本特性：</span><span class="inline-wrap"><a href="%E5%B9%B6%E5%8F%91%E6%80%A7/%E5%B9%B6%E5%8F%91%E6%80%A7.html#gBoScfUTnfrim3qvd4XYwY" class="wolai-bi-link"><span class="embed-page">并发性</span></a></span><span class="inline-wrap">和共享性</span></aside><h4 id="8mu1FabJ3tmgK3KjRxA4zm" class="wolai-block"><span class="inline-wrap">所以我们引入了进程这一概念。</span></h4><aside id="7kCRKFoKztPabFfBSZsTCp" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">操作系统为什么引入进程？</span><div id="t3QvGTSBe1yyPnLKSW7zuc" class="wolai-block wolai-text"><div><span class="inline-wrap">操作系统引入进程的原因是为了使程序在多道程序环境下能并发执行，并能对并发执行的程序加以控制和描述，从而实现对计算机系统的有效管理和调度<span class="jill"></span>¹。

源: 与必应的对话， 2023/4/5
(1) 在操作系统中为什么要引入进程这一概念-常见问题-PHP<span class="jill"></span>中文网. </span><span class="inline-wrap"><a href="https://www.php.cn/faq/475561.html"><span>https://www.php.cn/faq/475561.html</span></a></span><span class="inline-wrap">.
(2) 在操作系统中为什么要引入进程概念？_百度知道. </span><span class="inline-wrap"><a href="https://zhidao.baidu.com/question/403649373.html"><span>https://zhidao.baidu.com/question/403649373.html</span></a></span><span class="inline-wrap">.
(3) 操作系统为什么要引入进程？ - 知乎. </span><span class="inline-wrap"><a href="https://www.zhihu.com/question/47877636"><span>https://www.zhihu.com/question/47877636</span></a></span><span class="inline-wrap">.
(4) 操作系统学习笔记（day3）进程状态及转换_引入创建、终止状态的原因_RaspberryfC.的博客-CSDN<span class="jill"></span>博客. </span><span class="inline-wrap"><a href="https://blog.csdn.net/weixin_44952214/article/details/105877476"><span>https://blog.csdn.net/weixin_44952214/article/details/105877476</span></a></span><span class="inline-wrap">.</span></div></div></aside><h1 id="wL9drZoKNQm3QuxJQJg1Bv" class="wolai-block"><span class="inline-wrap">进程的状态及状态间的转换</span></h1><div id="sEqNUc9xVbPtWPb2K2cvCJ" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.html"><span>进程的状态及状态之间的转换</span></a></div><h2 id="eP1uhQY8Q6Uq2ZWX1nPZUv" class="wolai-block"><span class="inline-wrap">PCB(shed.h) task_struct</span></h2><blockquote id="wYKv6tW3K2hC3tMGNGJooU" class="wolai-block"><span class="inline-wrap">为了使参与并发执行的每个程序（含数据）都能独立地运行，必须为之配置一个专门的数据结构，成为进程控制块（process control block，PCB）</span><div id="oZWLuNJCfzqpWQns7WvrwD" class="wolai-block wolai-text"><div><span class="inline-wrap">系统利用<span class="jill"></span>PCB<span class="jill"></span>来描述进程的基本情况和运行状态，进而控制和管理进程。</span></div></div><aside id="jBZruEug5zdm49EoUTK8vb" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap"> PCB<span class="jill"></span>是进程存在的唯一标志</span></aside></blockquote><aside id="xpkK1uHbCMDJv38f35AbX8" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">这个文件在</span><span class="inline-wrap"><a href="https://blog.csdn.net/ASKLW/article/details/73518802"><span>include</span></a></span><span class="inline-wrap">文件夹中</span></aside><div id="ey5tLQ1WTZHGyAeMfmNgfB" class="wolai-block wolai-text"><div><span class="inline-wrap">100<span class="jill"></span>多个成员变量</span></div></div><div id="wP4bnKJMp3uAXc98iUKEvt" class="wolai-block wolai-text"><div><span class="inline-wrap">进程调度(state,flags,counter,nice,policy…)</span></div></div><div id="7AxYd7BPe7LRRV722KJBoS" class="wolai-block wolai-text"><div><span class="inline-wrap">存储管理(mm_struct*mm)</span></div></div><div id="kmZojy9EQJ9njvHp4v5otT" class="wolai-block wolai-text"><div><span class="inline-wrap">SMP<span class="jill"></span>管理</span></div></div><div id="a2QiuoP7CU8uMDcEje8ydu" class="wolai-block wolai-text"><div><span class="inline-wrap">队列指针</span></div></div><div id="mtFu53nL63NgeDWtxFsSq4" class="wolai-block wolai-text"><div><span class="inline-wrap">进程标识(pid,pgrp,tgid…)</span></div></div><div id="rPFGQR91akg2JjM4qXUYM1" class="wolai-block wolai-text"><div><span class="inline-wrap">进程家族关系</span></div></div><div id="rriLWfrR4MLfXm4aMiVbsW" class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/457403125">超详解的Linux内核进程描述符task_struct结构体，不能再详细了</a><div class="info-box"><div class="text-pane"><div data-title="超详解的Linux内核进程描述符task_struct结构体，不能再详细了"></div><div data-desc="进程是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称。注意，程序并不是进程，实际上两个或多个进程不仅有可能执行同一程序，而且还有可能共享地址空间等资源。…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://pic1.zhimg.com/v2-84c310e60607783b2e5aa666eb89f001_720w.gif?source=172ae18b)"></div></div></div><div id="7CBRmay8SGo4kztdbozvaq" class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/qq_40871466/article/details/103510297">linux1.0操作系统源码剖析 sched.h sched.c_EW_DUST的博客-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="linux1.0操作系统源码剖析 sched.h sched.c_EW_DUST的博客-CSDN博客"></div><div data-desc="#ifndef _SCHED_H#define _SCHED_H#define NR_TASKS 64  //系统最多的进程数#define HZ 100       // 系统时钟频率 100HZ#define FIRST_TASK task[0]      //任务0是  比较特殊 init()#define LAST_TASK task[NR_TASKS-1]  //任务数组里..."></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><div id="6h9dopG86zm9AVPeZXkocp" class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/qq_31442743/article/details/129431554">Linux-0.11 kernel目录进程管理sched.c详解_程序员小x的博客-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="Linux-0.11 kernel目录进程管理sched.c详解_程序员小x的博客-CSDN博客"></div><div data-desc="Linux-0.11 kernel目录进程管理sched.c详解"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><h2 id="epwPhf5CSSSH6z2aCXxsjL" class="wolai-block"><span class="inline-wrap">fork</span></h2><div id="2Urimew1sJsP622TGLmf1" class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/130873706">论fork()函数与Linux中的多线程编程</a><div class="info-box"><div class="text-pane"><div data-title="论fork()函数与Linux中的多线程编程"></div><div data-desc="一、fork()函数 在操作系统的基本概念中进程是程序的一次执行，且是拥有资源的最小单位和调度单位（在引入线程的操作系统中，线程是最小的调度单位）。在Linux系统中创建进程有两种方式：一是由操作系统创建，二是…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane"></div></div></div><div id="6tVoKs6uC1Z99UkfBpiBgt" class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/8692227">Linux C编程--fork()详解_fork.c_BruceZhang的博客-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="Linux C编程--fork()详解_fork.c_BruceZhang的博客-CSDN博客"></div><div data-desc="在Linux系统下学习一个系统函数最好的方法就是阅读其源码，首先，给出fork函数的源码/**  linux/kernel/fork.c*                                //－－fork()用于创建子进程*  (C) 1991  Linus Torvalds*//**  &apos;fork.c&apos; contains the help-routines fo"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><div id="qRTkiaFXBusQ7XmEaiz6GV" class="wolai-bookmark wolai-block"><a href="https://www.cnblogs.com/chenxinshuo/p/11968329.html">Linux 系统调用 —— fork 内核源码剖析 - 陈心朔 - 博客园</a><div class="info-box"><div class="text-pane"><div data-title="Linux 系统调用 —— fork 内核源码剖析 - 陈心朔 - 博客园"></div><div data-desc="系统调用 fork 在内核中做了什么？"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://common.cnblogs.com/favicon.svg&quot;)"></div><div data-hostname="www.cnblogs.com"></div></div></div><div class="preview-pane"></div></div></div><h3 id="bzMoBo48PBowToxvX4wVSp" class="wolai-block"><span class="inline-wrap">EX</span></h3><code-block id="imgsVpUMZV68c4bsySZ9Le" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>pid1<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>
pid2<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>
pid3<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>
pid4<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>
pid1<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword control-flow">if</span><span class="token punctuation">(</span>pid1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  pid2<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword control-flow">else</span>
<span class="token punctuation">{</span>
  pid3<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
pid4<span class="token operator">=</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="g8rxv7gZFM4CgEF2vpSf1M" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image.png" style="width: 306.4px"/></figure></div><h1 id="aBaifYJSPZthb8qNwDh6tL" class="wolai-block"><span class="inline-wrap">线程</span></h1><h3 id="sDXgGKGrKMRFmGmFa1gqWR" class="wolai-block"><span class="inline-wrap">Linux 内核线程</span></h3><div id="fUoyYFvbbocbmmntMioDR7" class="wolai-block wolai-text"><div><span class="inline-wrap">内核空间的进程</span></div></div><aside id="way3YcXYc1FDUgQdjfjrDP" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">共享内核地址的空间</span></aside><h2 id="5xK825v5dU9aN4GCdF6Mgi" class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>不支持（用户级的）内核线程</span></h2><aside id="dZce9EoZhHovaPdNJJXoRZ" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">我们现在说的概念上的线程 </span></aside><h2 id="rMg1qVvqC1puU9vnDuA8ZU" class="wolai-block"><span class="inline-wrap">Makefile</span></h2><aside id="3C3qwTLAoTggKRjzboU8TX" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">一个工程管理工具</span></aside><h3 id="gedBf7Je1AFrNo1PR8Kyv2" class="wolai-block"><span class="inline-wrap"><code>make</code></span></h3><div id="33rfjUQhRsKXGWHu3UXo77" class="wolai-block wolai-text"><div><span class="inline-wrap">可以通过</span><span class="inline-wrap"><code>makefile</code></span><span class="inline-wrap">文件快读构建项目</span></div></div><aside id="dXo4S2JnzW3UDY9cWQVAKJ" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">其实就是<span class="jill"></span>cmake??</span></aside><h2 id="3RChbLtgcz83KAz25Yq7VH" class="wolai-block"><span class="inline-wrap">多线程并发</span></h2><div id="i2dfMkv8dxGYe9XAP9u79o" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91.html"><span>多线程并发</span></a></div><h2 id="83Qgs7EYi7uD5QMBgptCtj" class="wolai-block"><span class="inline-wrap"><a href="https://www.wolai.com/3YMYSPpC91bL44K15PXzr6#3YMYSPpC91bL44K15PXzr6" class="wolai-bi-link"><span class="embed-page">JAVA</span></a></span><span class="inline-wrap">线程</span></h2><aside id="7iyUqMwUgiyKXGnsFzgdyS" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">JAVA<span class="jill"></span>实际上是在虚拟机下执行的，但是我们也不妨把这个虚拟机理解为一个操作系统</span></aside><div id="ev5qCBzUs4HbSvN8mJRjft" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="tZT4fSkWYaFvktukPJF8nH" class="wolai-block"><span class="inline-wrap">临界区与临界资源</span></h1><h3 id="dPfhGTgBqh291p6Q6Q2F9K" class="wolai-block"><span class="inline-wrap">临界资源(Critical Resource)</span></h3><div id="t5vUGtQNQvWMyFr6ZP3P5J" class="wolai-block wolai-text"><div><span class="inline-wrap">同时只能允许<span class="jill"></span>1<span class="jill"></span>个进程访问的资源</span></div></div><div id="7uwrq3egh55p1U45jGPKKS" class="wolai-block wolai-text"><div><span class="inline-wrap">并发进程共享访问临界资源时必须互斥</span></div></div><h2 id="88gJGhnf1y5GA7b1RPXkvM" class="wolai-block"><span class="inline-wrap">循环缓冲池</span></h2><div id="9eU52HViP2Afbjxj9bJ1Vt" class="wolai-block wolai-text"><div><span class="inline-wrap">定义如下：</span></div></div><code-block id="3bpSC7Xha1AQ4AY2BGFqx3" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>Producer<span class="token operator">-</span>Consumer
Const <span class="token keyword">int</span> n<span class="token operator">=</span>N
Int in<span class="token punctuation">,</span>out<span class="token punctuation">,</span>counter<span class="token punctuation">;</span>     <span class="token comment">/*initial to 0*/</span>
Typedef Struct  <span class="token punctuation">{</span>…<span class="token punctuation">}</span> item<span class="token punctuation">;</span> <span class="token comment">//定义一个结构体作为一个缓冲区</span>
Struct item buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre></div></code-block><div id="qr5jdr7psBtfjs6KR5CBPF" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="cMqYe4oMAPf5MEdHp9BQJT" class="wolai-block wolai-text"><div><span class="inline-wrap">对一个生产者的应该如何操作捏？</span></div></div><aside id="m3nN2odut9YVC9xrrdGr6e" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">我超这还分生产者进程和消费者进程的？？</span></aside><code-block id="4AjGgnm7MgYWdEn4vcDLa" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
   …producer an item in…
   <span class="token keyword">while</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">// 如果装满数据了就应该等</span>
   buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span><span class="token operator">=</span> thisitem<span class="token punctuation">;</span><span class="token comment">// 没有装满就塞进去</span>
   in<span class="token operator">=</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>in<span class="token operator">==</span>n<span class="token punctuation">)</span> in<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 循环缓冲池</span>
   counter<span class="token operator">=</span>counter<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// counter指示缓冲池中的个数</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span>counter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
   thisitem<span class="token operator">=</span>buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>
   out<span class="token operator">=</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token operator">==</span>n<span class="token punctuation">)</span> out<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
   …consumer thisitem…
   counter<span class="token operator">=</span>counter<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</pre></div></code-block><aside id="dQEGvvLK7jfZ9KzrbCq7yT" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">HXL：上面这个代码是个新手程序员写出来的捏，实际上会有问题捏</span></aside><h3 id="9wbySutCUAiLZxRa7oW6S1" class="wolai-block"><span class="inline-wrap">一个问题：</span></h3><div id="fcwdhsXV8ZNidQxRbviWjN" class="wolai-block wolai-text"><div><span class="inline-wrap">首先考虑只有<span class="jill"></span>1<span class="jill"></span>个<span class="jill"></span>producer<span class="jill"></span>和<span class="jill"></span>1<span class="jill"></span>个<span class="jill"></span>consumer</span></div></div><div id="rsGkcEpadVzwtrqVCnN2k4" class="wolai-block wolai-text"><div><span class="inline-wrap">共享变量<span class="jill"></span>counter，并且都要改变该变量</span></div></div><div id="qizFvLHN5b6khykxH8Zfa6" class="wolai-block wolai-text"><div><span class="bg-fluorescent_yellow inline-wrap"><b>高级语言<span class="jill"></span>counter=counter+(-)1<span class="jill"></span>编译后可能是通过多个指令实现的:</b></span></div></div><code-block id="gPWkdZcaww127mkB2eX8M8" class="wolai-block"><div class="wolai-pre"><div data-lang="C" class="marker"></div><pre>mov ax<span class="token punctuation">,</span>counter
add ax<span class="token punctuation">,</span><span class="token punctuation">(</span>dec ax<span class="token punctuation">)</span>
mov counter<span class="token punctuation">,</span>ax
</pre></div></code-block><div id="s8EYCZAkzDaLR56bniyjGx" class="wolai-block wolai-text"><div><span class="inline-wrap">并发执行时，可能会交织执行而产生错误结果</span></div></div><div id="sxKMtrDcq5EJMHTzgUwjUx" class="wolai-block wolai-text"><div><span class="inline-wrap">Counter<span class="jill"></span>为临界变量(资源)，必须互斥访问</span></div></div><h3 id="9BfYVjZE2TN2dLpeBci5sT" class="wolai-block"><span class="inline-wrap">解决方案：临界区（critical section)</span></h3><div id="aBp2F9y9KwfKm71DsEaXzK" class="wolai-block wolai-text"><div><span class="inline-wrap">进程中访问临界资源的那段代码</span></div></div><div id="wFTQ4pTGnZip655qGhSZGw" class="wolai-block wolai-text"><div><span class="inline-wrap">在进入临界区时检查可否进入，退出时也必须做相应处理，即同步机制</span></div><div id="7MvVyfJKWodampYBrdN3Df" class="wolai-block wolai-text"><div><span class="inline-wrap">…</span></div></div><div id="q1UtWk2wgcZHYwA8bzJe2Z" class="wolai-block wolai-text"><div><span class="inline-wrap">进入区</span></div></div><div id="xz2c3WkFPrCrB1NyAtTfc9" class="wolai-block wolai-text"><div><span class="inline-wrap">临界区</span></div></div><div id="aoNfFqqmk83hd9hkHY28t3" class="wolai-block wolai-text"><div><span class="inline-wrap">退出区</span></div></div><div id="tYwz2ZT1aSNKHzJxQrvE1d" class="wolai-block wolai-text"><div><span class="inline-wrap">…</span></div></div></div><h3 id="mjnHXGgeoU7srVBWM61xiU" class="wolai-block"><span class="inline-wrap">同步机制应遵循的准则</span></h3><div id="21JzEZJo92ddizKxU5hy54" class="wolai-block wolai-text"><div><span class="inline-wrap">空闲让进</span></div></div><div id="iHYrmV2hWAMQpxK2ABZnSe" class="wolai-block wolai-text"><div><span class="inline-wrap">忙则等待</span></div></div><div id="fG3699c4DnwxdbTPWWQ7DA" class="wolai-block wolai-text"><div><span class="inline-wrap">有限等待</span></div></div><div id="4m2nD1dNEGhr75Ww82eaAn" class="wolai-block wolai-text"><div><span class="inline-wrap">让权等待</span></div></div><ul class="wolai-block"><li id="es6MFzyqH7nT43RWLuJdmi"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>平等竞争：</b></span><span class="inline-wrap">即各并发进程享有平等地、独立地竞争共有资源的权利，且在不采取任何措施的条件下，在临界区内任意指令结束时，其他并发进程可以进入临界区。</span></li><li id="eCKTm6a9fDdmLnCZMCELyR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>互斥使用</b></span><span class="inline-wrap">：当并发进程中的时候 多个进程同时申请进入临界区时，它只允许一个进程进入临界区。</span></li><li id="tQBjfeHYFeDPPY1MgJKEfk"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>不可独占：</b></span><span class="inline-wrap">当进程不在临界区后，它不能阻止其他进程进入临界区。</span></li><li id="iZAhDRo168F4vEqeJ5uPJM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>有限等待：</b></span><span class="inline-wrap">也就是在就绪队列中的进程等待资源时间必须是有限的。并发进程中的某个进程从申请进入临界区时开始，应在有限时间内得以进入临界区。</span></li></ul><aside id="9LwGEQ5JLsQNBbCQYJeQJ5" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">在<span class="jill"></span>CPU<span class="jill"></span>忙时，通过阻塞进程来实现让全等待</span></aside><div id="qydfKYw4yJTTc7eR16kaK4" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="k8LMsd7uxRwhWDzrH2LXJM" class="wolai-block"><span class="inline-wrap">实现进程同步的方式</span></h2><h3 id="5UYhVRUA4GcZTiE36c7ZMB" class="wolai-block"><span class="inline-wrap">纯软件实现进程同步</span></h3><h4 id="rYmZT3fFxd4twmYH75KxnZ" class="wolai-block"><span class="inline-wrap">方法<span class="jill"></span>1</span></h4><div id="oDmSdx1nvvzsJwkeuGfu3D" class="wolai-block wolai-text"><div><span class="inline-wrap">问题:没有实现空闲让进、让权等待</span></div></div><div id="mqRpnP5qaTF5CkuAfsdzF7" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_2.png" style="width: 100%"/></figure></div><h4 id="kJKqo9mCbUuNG3sEhgjB8N" class="wolai-block"><span class="inline-wrap">方法<span class="jill"></span>2</span></h4><div id="kLz1xnDmUjA2FUFM3kcS59" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_3.png" style="width: 390.4px"/></figure></div><div id="smjBY2JrXb67tohgQk29cp" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="2.3%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/2.3%20%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5.html"><span>2.3 同步与互斥</span></a></div><h1 id="a4QchsiExKdi3E6PgRAo7d" class="wolai-block"><span class="inline-wrap">如何实现进程控制</span></h1><h2 id="pL2a84bGwpvFV1hTsDuRrq" class="wolai-block"><span class="inline-wrap">原语</span></h2><div id="UpVHSA7MfZmrLCWJMQhGH" class="wolai-block wolai-text"><div><span class="inline-wrap">用原语实现进程控制 原语的特点是执行期间不允许中断， 只能一气呵成
这种不可被中断的操作即原子操作
原语采用</span><span class="inline-wrap"><b> 关中断指令 开中断指令</b></span><span class="inline-wrap"> 实现</span></div></div><h2 id="wRDpDxSC27YFZFzuDeFu4H" class="wolai-block"><span class="inline-wrap">原子操作</span></h2><h3 id="vUUio57ZK58RUVnxSTcTh7" class="wolai-block"><span class="inline-wrap">实现方式</span></h3><div id="oPpyQVFN7VwK5gvDHrhZx6" class="wolai-block wolai-text"><div><span class="inline-wrap">硬件指令(swap,testand set,…)</span></div></div><div id="bNrYcS14pz6Rnw3R61CH4j" class="wolai-block wolai-text"><div><span class="inline-wrap">CLI<span class="jill"></span>指令(单<span class="jill"></span>cpu)</span></div></div><div id="3zmupdxD4xwMFyzPo15ZyS" class="wolai-block wolai-text"><div><span class="inline-wrap">Lock<span class="jill"></span>指令(多<span class="jill"></span>cpu)</span></div></div><div id="dWYmNPnkCXFPQs3gGdh4QS" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_4.png" style="width: 100%"/></figure></div><div id="sLXSVH3w9KrLmnWGHjpjW6" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="2.4%20%E6%AD%BB%E9%94%81/2.4%20%E6%AD%BB%E9%94%81.html"><span>2.4 死锁</span></a></div><h2 id="igYTJejcCFiKUZpCSBLHpz" class="wolai-block"><span class="inline-wrap">2.3.2 实现临界区互斥的基本方法</span></h2></article><footer></footer></body></html>