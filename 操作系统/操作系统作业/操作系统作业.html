<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>操作系统作业 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="操作系统作业" class="main-title"></div></div></header><article><div id="bEhA4Px3NuH9Z6H4i7SzWF" class="wolai-file-block wolai-block"><div class="file-icon" style="background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; width=&apos;24&apos; height=&apos;24&apos; viewBox=&apos;0 0 24 24&apos;%3E%3Cg fill=&apos;none&apos; fill-rule=&apos;evenodd&apos;%3E%3Cpath d=&apos;M12.4 1.5a1.6 1.6 0 011.593 1.454L14 3.1v2.4a2 2 0 001.85 1.995L16 7.5h2.4a1.6 1.6 0 011.593 1.454L20 9.1l-.001 11.424-.004.125A2 2 0 0118 22.5H6a2 2 0 01-2-2v-17a2 2 0 012-2h6.4zm2.58 1.283l3.74 3.736a2.626 2.626 0 00-.32-.019H16a1 1 0 01-1-1V3.1c0-.107-.007-.213-.02-.317z&apos; fill=&apos;%23FA0F00&apos;%3E%3C/path%3E%3Cpath d=&apos;M17.533 14.758c-.832-.885-3.135-.525-3.675-.435-.795-.772-1.35-1.687-1.537-2.025.3-.855.495-1.762.525-2.655 0-.81-.323-1.68-1.223-1.68a.912.912 0 00-.757.443c-.383.66-.233 2.025.382 3.405-.36 1.012-.877 2.475-1.56 3.66-.922.367-2.88 1.267-3.067 2.265a.842.842 0 00.27.795c.217.195.502.292.795.285 1.177 0 2.355-1.635 3.15-3.038.667-.232 1.732-.54 2.805-.735 1.245 1.088 2.355 1.253 2.917 1.253.765 0 1.05-.33 1.155-.608a.937.937 0 00-.18-.93zm-.81.57c-.037.218-.315.435-.832.323a4.165 4.165 0 01-1.635-.825c.405-.068 1.35-.158 2.017-.03.24.045.518.18.45.532zm-5.37-6.637a.301.301 0 01.263-.165c.285 0 .345.345.345.63a8.759 8.759 0 01-.375 2.002c-.48-1.275-.413-2.16-.233-2.467zm-.067 6.232c.255-.502.615-1.417.742-1.785a9.452 9.452 0 001.02 1.335 16.87 16.87 0 00-1.762.45zm-1.883 1.29c-.757 1.215-1.5 1.98-1.935 1.98a.308.308 0 01-.195-.067.28.28 0 01-.097-.278c.082-.435.945-1.065 2.227-1.635z&apos; fill=&apos;%23FFF&apos; fill-rule=&apos;nonzero&apos;%3E%3C/path%3E%3C/g%3E%3C/svg%3E&quot;);"></div><a href="media/%E8%AE%B8%E6%84%BF%20%E7%AC%AC%E4%B8%89%E5%91%A8%20%E5%91%A8%E4%B8%80.pdf"><span>许愿 第三周 周一.pdf</span><span data-size="2.52 MB" class="file-size"></span></a></div><div id="fWaKoy2Z7hyTHFgeQwf6aq" class="wolai-file-block wolai-block"><div class="file-icon" style="background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; width=&apos;24&apos; height=&apos;24&apos; viewBox=&apos;0 0 24 24&apos;%3E%3Cg fill=&apos;none&apos; fill-rule=&apos;evenodd&apos;%3E%3Cpath d=&apos;M12.4 1.5a1.6 1.6 0 011.593 1.454L14 3.1v2.4a2 2 0 001.85 1.995L16 7.5h2.4a1.6 1.6 0 011.593 1.454L20 9.1l-.001 11.424-.004.125A2 2 0 0118 22.5H6a2 2 0 01-2-2v-17a2 2 0 012-2h6.4zm2.58 1.283l3.74 3.736a2.626 2.626 0 00-.32-.019H16a1 1 0 01-1-1V3.1c0-.107-.007-.213-.02-.317z&apos; fill=&apos;%23FA0F00&apos;%3E%3C/path%3E%3Cpath d=&apos;M17.533 14.758c-.832-.885-3.135-.525-3.675-.435-.795-.772-1.35-1.687-1.537-2.025.3-.855.495-1.762.525-2.655 0-.81-.323-1.68-1.223-1.68a.912.912 0 00-.757.443c-.383.66-.233 2.025.382 3.405-.36 1.012-.877 2.475-1.56 3.66-.922.367-2.88 1.267-3.067 2.265a.842.842 0 00.27.795c.217.195.502.292.795.285 1.177 0 2.355-1.635 3.15-3.038.667-.232 1.732-.54 2.805-.735 1.245 1.088 2.355 1.253 2.917 1.253.765 0 1.05-.33 1.155-.608a.937.937 0 00-.18-.93zm-.81.57c-.037.218-.315.435-.832.323a4.165 4.165 0 01-1.635-.825c.405-.068 1.35-.158 2.017-.03.24.045.518.18.45.532zm-5.37-6.637a.301.301 0 01.263-.165c.285 0 .345.345.345.63a8.759 8.759 0 01-.375 2.002c-.48-1.275-.413-2.16-.233-2.467zm-.067 6.232c.255-.502.615-1.417.742-1.785a9.452 9.452 0 001.02 1.335 16.87 16.87 0 00-1.762.45zm-1.883 1.29c-.757 1.215-1.5 1.98-1.935 1.98a.308.308 0 01-.195-.067.28.28 0 01-.097-.278c.082-.435.945-1.065 2.227-1.635z&apos; fill=&apos;%23FFF&apos; fill-rule=&apos;nonzero&apos;%3E%3C/path%3E%3C/g%3E%3C/svg%3E&quot;);"></div><a href="media/%E8%AE%B8%E6%84%BF%20%E7%AC%AC%E5%85%AD%E5%91%A8%20%E5%91%A8%E4%B8%80.pdf"><span>许愿 第六周 周一.pdf</span><span data-size="7.02 MB" class="file-size"></span></a></div><div id="2W8XwXPqRm9Nr8BF7bwRHt" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/$f3h37%5Dovv%5B6m(mywxsethx.jpg" style="width: 100%"/></figure></div><div id="6zyDjAioykZTLxHKczfSUS" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/3dx%7D-%7B9c%7Dq%7Bq%5D5gs5uh5$~c.jpg" style="width: 100%"/></figure></div><h2 id="vZg5bKg2uP8pWD8ZRgpbA7" class="wolai-block"><span class="inline-wrap">初步计算一下从你机器的硬盘读取扇区需要的时间，其中<span class="jill"></span>CPU<span class="jill"></span>执行指令花了多长时间？多道程序设计解决了什么问题？</span></h2><div id="oGR4x4UZ2jfMCpe6ttTmgx" class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/u011240016/article/details/52882840">磁盘访问时间计算_磁盘访问时间由哪几部分组成?每部分时间应如何计算?_DrCrypto的博客-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="磁盘访问时间计算_磁盘访问时间由哪几部分组成?每部分时间应如何计算?_DrCrypto的博客-CSDN博客"></div><div data-desc="通常磁盘数据访问时间计算分为三个部分（实际上是四个，但是启动时间不加说明时忽略不计）：寻道时间，也称寻找时间：磁头移动到指定磁道需要的时间延迟时间：磁头定位到某一磁道的扇区所需要的时间传输时间：从磁盘读出或者写入经历的时间值得强调的是，寻找磁道的时间是最大的影响因子，因此各种调度算法目的都是为了优化寻道的时间。盘面上密密麻麻的同心圆，找到需要的那个想来就很费时间，再加上访问的数据不必在相邻或"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><div id="sSDAAgcVNQZgrkBrSTd49k" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image.png" style="width: 100%"/></figure></div><div id="3Ev9SKV1VovJLyGkGynoPw" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="gLiVcv5hQybW9Wfe7tQmYo" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_2.png" style="width: 100%"/></figure></div><div id="d5pDzCbBiCwnPXrt5k9FyG" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_3.png" style="width: 459.2px"/></figure></div><div id="4GFuXeA3GWemfgB14D2gwm" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/cd1603d615a93f2402380eff7dfdccd.png" style="width: 100%"/></figure></div><div id="mCmkfvkyrSXnPCS7K8CYN4" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/aba38add5029bcc959f1906ddd9c641.png" style="width: 100%"/></figure></div><div id="995pkYpCyYE1bcNcuXgdzC" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/6533b04ea8f26abd662ac9706eaa90d.png" style="width: 662.4px"/></figure></div><h2 id="myt1N6vxc89axSFQ1Hssrz" class="wolai-block"><span class="inline-wrap">解释<span class="jill"></span>linuxPCB<span class="jill"></span>中各个数据元素的含义</span></h2><div id="81a4uX1BpREijRQsEZsCw2" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Linux<span class="jill"></span>中，进程控制块（Process Control Block，PCB）是操作系统内部的数据结构，用于保存一个进程的所有信息。PCB<span class="jill"></span>中包含了操作系统所需要的所有信息，以便于操作系统进行进程调度和管理。下面是<span class="jill"></span>PCB<span class="jill"></span>中一些重要的数据元素及其含义：</span></div></div><ol class="wolai-block"><li id="m6XBknYhgjPgv2aMA7ZqYV"><div class="marker"></div><span class="inline-wrap">进程状态（state）：表示进程当前的状态，包括就绪态、运行态、等待态等。</span></li><li id="a4FDK92NyS6yWUkVg9q74R"><div class="marker"></div><span class="inline-wrap">进程<span class="jill"></span>ID（pid）：每个进程在系统中都有唯一的进程<span class="jill"></span>ID，用于区分不同的进程。</span></li><li id="vEXLrh5JziJTQQqU17CtP5"><div class="marker"></div><span class="inline-wrap">父进程<span class="jill"></span>ID（ppid）：表示当前进程的父进程<span class="jill"></span>ID。</span></li><li id="8wTb9U9KxE6fSyowr8QBMR"><div class="marker"></div><span class="inline-wrap">进程优先级（priority）：表示进程的优先级，用于操作系统进行进程调度。</span></li><li id="aWCGRUxMyHVL7DqnbnmjQc"><div class="marker"></div><span class="inline-wrap">CPU<span class="jill"></span>时间（cpu time）：表示进程在<span class="jill"></span>CPU<span class="jill"></span>上运行的时间，包括用户态和内核态的时间。</span></li><li id="qX4mvN5qa9aSptBvFkZvRw"><div class="marker"></div><span class="inline-wrap">上下文（context）：表示进程的上下文信息，包括寄存器状态、内存映像、打开文件等。</span></li><li id="rbBiHKBtXjiHSEZkWqKNJ6"><div class="marker"></div><span class="inline-wrap">文件描述符表（file descriptor table）：表示进程打开的文件和网络连接等。</span></li><li id="hCv9nin1SXg3p3eRLmTB3K"><div class="marker"></div><span class="inline-wrap">内存管理信息（memory management information）：表示进程的内存使用情况，包括进程所占用的内存地址空间、进程的堆栈等。</span></li><li id="kpTuY42iFS2mBdzU4zU9xZ"><div class="marker"></div><span class="inline-wrap">信号处理表（signal handling table）：表示进程对不同信号的处理方式。</span></li></ol><div id="idKctzHyPB8f4xpYene4sA" class="wolai-block wolai-text"><div><span class="inline-wrap">这些数据元素是进程控制块中的重要信息，操作系统通过这些数据元素进行进程的管理和调度。</span></div></div><h2 id="sZUYaxohEwEdPqFpvM1KWj" class="wolai-block"><span class="inline-wrap">如果没有操作系统，应该怎么使用计算机呢？</span></h2><div id="8fexeAjviKdM1g2pgnxea" class="wolai-block wolai-text"><div><span class="inline-wrap">在没有操作系统的情况下，使用计算机将会非常困难。没有操作系统，计算机无法运行任何应用程序或执行任何任务。因此，要使用计算机，需要编写程序并手动将其加载到计算机内存中，这需要具有非常深厚的计算机知识和技能。</span></div></div><div id="nf7qDc1nS4wcENAUnc93GC" class="wolai-block wolai-text"><div><span class="inline-wrap">此外，还需要手动管理计算机的所有硬件资源，包括内存、外部存储器、输入/输出设备等。例如，在没有操作系统的情况下，要从硬盘上读取文件，需要知道硬盘的物理布局并编写程序来读取数据。</span></div></div><div id="8dXxDXFVHX7JTyqK4Rot6d" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，没有操作系统的情况下使用计算机是非常困难和耗时的，需要具有深厚的计算机知识和技能，以及大量的时间和精力。因此，现代计算机都配备了操作系统，以使计算机的使用更加简单、高效和可靠</span></div></div><div id="7Eb5tqbZYmYJUJwjDAQ8K1" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>可以具体说说吗</b></span></div></div><div id="rXdBJeDZCX9UzpXE5gxPyv" class="wolai-block wolai-text"><div><span class="inline-wrap">没有操作系统的计算机需要通过硬件直接与计算机交互。这意味着用户必须手动控制所有的硬件，包括读取和写入磁盘、加载程序和数据、管理内存等。这样的方式不仅非常复杂和困难，而且容易出错，需要大量的技术知识和经验。</span></div></div><div id="71TZESUYjnWHcP6YQwvk1P" class="wolai-block wolai-text"><div><span class="inline-wrap">例如，在没有操作系统的情况下，用户必须通过二进制代码编写程序，并手动将其加载到计算机的内存中。他们必须手动管理内存，确保程序不会覆盖其他程序或数据，还需要在计算机上安装和配置所有需要的驱动程序。这需要大量的时间和专业知识，并且容易出错。</span></div></div><div id="wwCJuzXUC1Y2eoAYZsCJMz" class="wolai-block wolai-text"><div><span class="inline-wrap">另外，没有操作系统的计算机没有图形用户界面，用户必须通过命令行界面来操作计算机，这需要记住大量的命令和选项，并且很难进行可视化操作。</span></div></div><div id="kexAiDARbGHMUUT9DiqeLp" class="wolai-block wolai-text"><div><span class="inline-wrap">因此，操作系统的发展使得计算机的使用变得更加容易和高效。它们提供了友好的用户界面、自动化的任务管理、内存管理、驱动程序管理、网络支持等功能，使得计算机的使用变得更加方便和高效。</span></div></div><h2 id="9toVScvAbcMmLN6Sib56BT" class="wolai-block"><span class="inline-wrap">各个操作系统分别有什么优点？</span></h2><div id="aN2zMhKyr2vJmF1azQBwvu" class="wolai-block wolai-text"><div><span class="inline-wrap">不同操作系统有不同的设计目标和适用场景，因此它们各自的优点也不同。以下是一些主要操作系统的优点：</span></div></div><ol class="wolai-block"><li id="cw1YHUSkrNJHLr2DR8Bf3T"><div class="marker"></div><span class="inline-wrap">Windows：Windows<span class="jill"></span>是最广泛使用的操作系统之一，它具有良好的兼容性和易用性，提供了广泛的应用程序和游戏支持，同时也是许多企业和组织使用的首选操作系统。</span></li><li id="2dW97oBrVuwJzskFtzWFno"><div class="marker"></div><span class="inline-wrap">macOS：macOS<span class="jill"></span>是苹果公司的操作系统，它具有优秀的界面设计、高效的性能和安全性能，还提供了强大的多媒体和生产力应用程序。</span></li><li id="q3DNbrcaxubUdaWZnRr2K4"><div class="marker"></div><span class="inline-wrap">Linux：Linux<span class="jill"></span>是一种开源操作系统，它免费、稳定、高度可定制，还支持广泛的硬件平台和应用程序。因此，Linux<span class="jill"></span>在服务器、嵌入式系统和超级计算机等领域得到了广泛应用。</span></li><li id="wSUdusMwgCBmdNSuVJmR5F"><div class="marker"></div><span class="inline-wrap">iOS：iOS<span class="jill"></span>是苹果公司开发的移动操作系统，它具有流畅的用户界面、高效的性能和良好的安全性能，还提供了许多高质量的应用程序和游戏。</span></li><li id="6GScdL7EqE7NkFF3Dvx5b7"><div class="marker"></div><span class="inline-wrap">Android：Android<span class="jill"></span>是一种基于<span class="jill"></span>Linux<span class="jill"></span>的开源移动操作系统，具有广泛的硬件支持、开放的应用程序平台和丰富的社区支持。因此，它在移动设备市场上得到了广泛应用。</span></li></ol><div id="LUVfmQ4XMJgL4aJL9hDny" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，操作系统的优点取决于它们的设计目标和适用场景，需要根据具体的使用需求和环境选择合适的操作系统。</span></div></div><h2 id="h64xY1U5Y7RBb6DPWgV4N1" class="wolai-block"><span class="inline-wrap">多道程序解决了什么问题</span></h2><div id="uJ8cTqNdwVCs6V1HrsJQGx" class="wolai-block wolai-text"><div><span class="inline-wrap">多道程序是指在计算机中同时运行多个程序，从而实现更好的计算机资源利用和更高的系统吞吐量。多道程序技术解决了以下几个问题：</span></div></div><ol class="wolai-block"><li id="2xJ741EqpH5iCfNKSSVzBx"><div class="marker"></div><span class="inline-wrap">提高系统资源利用率：多道程序技术使得多个程序可以共享计算机的各种资源，如<span class="jill"></span>CPU、内存、I/O<span class="jill"></span>设备等，从而提高了系统的资源利用率。在单道程序的情况下，如果程序在执行时需要等待<span class="jill"></span>I/O<span class="jill"></span>设备的数据，CPU<span class="jill"></span>就会闲置，这样会浪费计算机的资源。</span></li><li id="jjgbUAcJz5pkQzv7QQCY8G"><div class="marker"></div><span class="inline-wrap">提高系统的吞吐量：多道程序技术可以让多个程序同时运行，从而减少每个程序的等待时间，提高系统的吞吐量。如果每个程序都按照单道程序的方式执行，那么系统的吞吐量将非常低，用户等待的时间也会非常长。</span></li><li id="4SSu41P6qcEr6YjAvEe67y"><div class="marker"></div><span class="inline-wrap">提高了系统的响应时间：多道程序技术可以让多个程序同时运行，从而减少每个程序的等待时间，提高系统的响应时间。在单道程序的情况下，如果用户需要等待一个程序执行完毕才能运行下一个程序，那么用户等待的时间就会很长。而多道程序技术可以让多个程序同时运行，从而减少用户等待的时间，提高系统的响应时间。</span></li></ol><div id="jBih4scgiejRfPAWfLMpYS" class="wolai-block wolai-text"><div><span class="inline-wrap">总之，多道程序技术可以提高计算机系统的资源利用率、吞吐量和响应时间，从而提高系统的性能。</span></div></div><h2 id="5LPmMvcBV29bYjR5BMJTim" class="wolai-block"><span class="inline-wrap">请帮我编写建立进程、建立线程、控制进程、控制线程的四个应用程序</span></h2><h3 id="kDPmUmDgVqA3mH4RDSSAf3" class="wolai-block"><span class="inline-wrap">建立进程</span></h3><code-block id="5FZthXnJCttwbFG6wd4QC7" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
#include <span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span><span class="token property-access">h</span><span class="token operator">></span>
#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>wait<span class="token punctuation">.</span><span class="token property-access">h</span><span class="token operator">></span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent process started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>

    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 子进程</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child process started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token comment">// 执行子进程任务</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child process finished"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 父进程</span>
        <span class="token comment">// 等待子进程结束</span>
        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> nullptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent process ended"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 进程创建失败</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to create process"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</pre></div></code-block><h3 id="gKHZ7qFrg6dBxVZXH3ZYAh" class="wolai-block"><span class="inline-wrap">建立线程</span></h3><code-block id="sCTq9nbRynbKbsZceww2tv" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
#include <span class="token operator">&lt;</span>thread<span class="token operator">></span>

<span class="token keyword">void</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// 执行线程任务</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread finished"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 创建子线程</span>
    std<span class="token operator">:</span><span class="token operator">:</span>thread <span class="token function">t</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 等待子线程结束</span>
    t<span class="token punctuation">.</span><span class="token method function property-access">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Main thread ended"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
    <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div></code-block><h3 id="no21A2ZUaHqahvjvvKPuGz" class="wolai-block"><span class="inline-wrap">控制进程</span></h3><code-block id="sYNgU4dFs91os5oumUBYnC" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
#include <span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span><span class="token property-access">h</span><span class="token operator">></span>
#include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>wait<span class="token punctuation">.</span><span class="token property-access">h</span><span class="token operator">></span>

int <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent process started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>

    pid_t pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 子进程</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child process started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token comment">// 执行子进程任务</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child process still running, terminating..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token comment">// 终止子进程</span>
        <span class="token keyword control-flow">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 父进程</span>
        <span class="token comment">// 等待子进程执行一段时间后终止</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断子进程是否仍在运行</span>
        int status<span class="token punctuation">;</span>
        pid_t result <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token constant">WNOHANG</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Child process still running, terminating..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
            <span class="token comment">// 终止子进程</span>
            <span class="token function">kill</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">SIGTERM</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent process ended"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 进程创建失败</span>
        std<span class="token operator">:</span><span class="token operator">:</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to create process"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
        <span class="token keyword control-flow">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</pre></div></code-block><h3 id="hXFWnfZEy6W4o11Ytvg1ic" class="wolai-block"><span class="inline-wrap">控制线程</span></h3><code-block id="aukMWPjaDX6wiX15NWkkxr" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
#include <span class="token operator">&lt;</span>thread<span class="token operator">></span>

<span class="token keyword">void</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread started"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// 执行线程任务</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">:</span><span class="token operator">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread still running, terminating..."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">:</span><span class="token operator">:</span>endl<span class="token punctuation">;</span>
    <span class="token comment">// 终止</span>
</pre></div></code-block><h2 id="nm9ZVFj3xJHecovnBjhL6o" class="wolai-block"><span class="inline-wrap">在<span class="jill"></span>linux<span class="jill"></span>源码中找出进程切换的源码，并尝试解释它</span></h2><div id="iRLbF3sbRkFSLvpML3M2Rp" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Linux<span class="jill"></span>内核中，进程切换是由内核的调度器完成的。进程切换的主要代码位于<span class="jill"></span>sched/core.c<span class="jill"></span>文件中。具体来说，进程切换是通过内核中的<span class="jill"></span>context_switch()函数来实现的。</span></div></div><div id="jhyVXgACaUGgVFVuDenDBT" class="wolai-block wolai-text"><div><span class="inline-wrap">下面是<span class="jill"></span>context_switch()函数的代码：</span></div></div><code-block id="fQYCwjmmWcVEpyxMWyUTMS" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre><span class="token keyword">static</span> __always_inline <span class="token keyword">void</span>
<span class="token function">context_switch</span><span class="token punctuation">(</span><span class="token parameter">struct rq <span class="token operator">*</span>rq<span class="token punctuation">,</span> struct task_struct <span class="token operator">*</span>prev<span class="token punctuation">,</span>
               struct task_struct <span class="token operator">*</span>next</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        struct mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>
        struct thread_struct <span class="token operator">*</span>prev_thread<span class="token punctuation">,</span> <span class="token operator">*</span>next_thread<span class="token punctuation">;</span>
        struct task_struct <span class="token operator">*</span>p<span class="token punctuation">;</span>

        <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
         * We're now committed to switching context. Tell lockdep
         * about it.
         */</span>
        <span class="token function">lockdep_trace_context_switch</span><span class="token punctuation">(</span>rq<span class="token punctuation">,</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>

        prev_thread <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">;</span>
        next_thread <span class="token operator">=</span> <span class="token operator">&amp;</span>next<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">;</span>
        oldmm <span class="token operator">=</span> prev<span class="token operator">-</span><span class="token operator">></span>mm<span class="token punctuation">;</span>
        mm <span class="token operator">=</span> next<span class="token operator">-</span><span class="token operator">></span>mm<span class="token punctuation">;</span>

        <span class="token comment">/* ..省略其他代码..*/</span>

        <span class="token comment">/* perform context switch */</span>
        <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> prev_pgd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* bad! */</span>
<span class="token punctuation">}</span>
</pre></div></code-block><div id="5BJrCdqWoBJFSuQjNtCWKS" class="wolai-block wolai-text"><div><span class="inline-wrap">在这个函数中，我们可以看到它接受了三个参数：rq，prev<span class="jill"></span>和<span class="jill"></span>next。这里的<span class="jill"></span>rq<span class="jill"></span>是当前运行的运行队列，prev<span class="jill"></span>是当前正在运行的进程，next<span class="jill"></span>是将要运行的进程。</span></div></div><div id="ghXDjDEfHzpkwbtopn31M4" class="wolai-block wolai-text"><div><span class="inline-wrap">在函数中，它首先通过<span class="jill"></span>prev_thread<span class="jill"></span>和<span class="jill"></span>next_thread<span class="jill"></span>指针分别获取了<span class="jill"></span>prev<span class="jill"></span>和<span class="jill"></span>next<span class="jill"></span>的线程信息。然后通过<span class="jill"></span>oldmm<span class="jill"></span>和<span class="jill"></span>mm<span class="jill"></span>指针获取了<span class="jill"></span>prev<span class="jill"></span>和<span class="jill"></span>next<span class="jill"></span>的内存管理结构体。</span></div></div><div id="78TXUah4RXaWKC3yD5Dof8" class="wolai-block wolai-text"><div><span class="inline-wrap">接下来的代码对<span class="jill"></span>prev<span class="jill"></span>和<span class="jill"></span>next<span class="jill"></span>的状态进行了检查，并执行了一些必要的处理。最后，context_switch()函数调用了<span class="jill"></span>switch_to()函数来执行实际的进程切换。</span></div></div><div id="v1KVnoPkeLjvukSd8mPKQp" class="wolai-block wolai-text"><div><span class="inline-wrap">switch_to()函数是真正执行进程切换的函数，其代码如下：</span></div></div><code-block id="nChJrH4BzvMMyYVt3GnBPU" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>notrace __visible <span class="token keyword">void</span> __noreturn
<span class="token function">switch_to</span><span class="token punctuation">(</span><span class="token parameter">struct task_struct <span class="token operator">*</span>prev<span class="token punctuation">,</span> struct task_struct <span class="token operator">*</span>next<span class="token punctuation">,</span>
          struct page_table <span class="token operator">*</span>prev_pgd</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
        struct thread_struct <span class="token operator">*</span>prev_thread<span class="token punctuation">,</span> <span class="token operator">*</span>next_thread<span class="token punctuation">;</span>
        struct mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>oldmm<span class="token punctuation">;</span>

        <span class="token comment">/* ..省略其他代码..*/</span>

        prev_thread <span class="token operator">=</span> <span class="token operator">&amp;</span>prev<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">;</span>
        next_thread <span class="token operator">=</span> <span class="token operator">&amp;</span>next<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">;</span>
        oldmm <span class="token operator">=</span> prev<span class="token operator">-</span><span class="token operator">></span>mm<span class="token punctuation">;</span>
        mm <span class="token operator">=</span> next<span class="token operator">-</span><span class="token operator">></span>mm<span class="token punctuation">;</span>

        <span class="token comment">/* ..省略其他代码..*/</span>

        <span class="token function">__switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</pre></div></code-block><div id="rGWdhTaCz4wt73qwE1EzeM" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>switch_to()函数中，它首先获取了<span class="jill"></span>prev<span class="jill"></span>和<span class="jill"></span>next<span class="jill"></span>的线程和内存管理结构体，然后调用__switch_to()函数来执行实际的进程切换。在__switch_to()函数中，它通过汇编代码来切换进程的上下文，包括保存和恢复进程的寄存器、页表等。</span></div></div><div id="82sTDGvDXYNLZQhnSsSk12" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，进程切换的实现是非常复杂的，它需要处理很多细节，包括进程状态的转换、保存和恢复进程的寄存器和页表等。在<span class="jill"></span>Linux<span class="jill"></span>内核中，这些细节都被封装在了<span class="jill"></span>context_switch()和<span class="jill"></span>switch_to()函数中。</span></div></div><h3 id="dKs1uwPHZNtLj4prwagKUM" class="wolai-block"><span class="inline-wrap">2.2 __switch_to()函数</span></h3><div id="9THi5ABPomXaEapBZRNfF3" class="wolai-block wolai-text"><div><span class="inline-wrap">实际上大部分的进程切换工作是由__switch_to()函数完成的，它的参数是<span class="jill"></span>prev_p<span class="jill"></span>和<span class="jill"></span>next_p，分别指向旧进程和新进程。这个函数和普通的函数有些差别，因为__switch_to()函数从<span class="jill"></span>eax<span class="jill"></span>和<span class="jill"></span>edx<span class="jill"></span>寄存器中获取<span class="jill"></span>prev_p<span class="jill"></span>和<span class="jill"></span>next_p<span class="jill"></span>这两个参数（在分析<span class="jill"></span>switch_to<span class="jill"></span>宏的时候已经讲过），而不是像普通函数那样，从栈中获取参数。为了强制函数从寄存器中获取参数，内核使用</span><span class="inline-wrap"><code>__attribute__</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>regparm</code></span><span class="inline-wrap">进行声明。这是<span class="jill"></span>gcc<span class="jill"></span>编译器对<span class="jill"></span>C<span class="jill"></span>语言的一个非标准扩展。__switch_to()函数定义在</span><span class="inline-wrap"><code>include/asm-i386/system.h</code></span><span class="inline-wrap">文件中：</span></div></div><code-block id="vSihzNhcRsCv9WMwWjGHVw" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre><span class="token function">__switch_to</span><span class="token punctuation">(</span>struct task_struct <span class="token operator">*</span>prev_p<span class="token punctuation">,</span>
        struct task_struct <span class="token operator">*</span>next_p<span class="token punctuation">)</span>
        <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token function">regparm</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block><div id="sjnK7yYU4tJS8KA7H7gmSn" class="wolai-block wolai-text"><div><span class="inline-wrap">这个函数执行的内容：</span></div></div><ol class="wolai-block"><li id="jRG2DVyf1WEoPnsPNbwMic"><div class="marker"></div><span class="inline-wrap">执行__unlazy_fpu()宏，保存旧进程的<span class="jill"></span>FPU、MMX<span class="jill"></span>和<span class="jill"></span>XMM<span class="jill"></span>寄存器  </span><div id="aAu52irhVfU7QFAzLAQQEa" class="wolai-block wolai-text"><div><span class="inline-wrap">__unlazy_fpu(prev_p);</span></div></div></li><li id="4cw51FKyjZo2CqQF1rgVBb"><div class="marker"></div><span class="inline-wrap">执行<span class="jill"></span>smp_processor_id()宏，获取正在执行代码的<span class="jill"></span>CPU<span class="jill"></span>的<span class="jill"></span>ID。从<span class="jill"></span>thread_info<span class="jill"></span>结构的<span class="jill"></span>cpu<span class="jill"></span>成员中获取。</span></li><li id="v97cWiCFN6VuDdS9VN6sHT"><div class="marker"></div><span class="inline-wrap">加载新进程的</span><span class="inline-wrap"><code>next_p-&gt;thread.esp0</code></span><span class="inline-wrap">到当前<span class="jill"></span>CPU<span class="jill"></span>的<span class="jill"></span>TSS<span class="jill"></span>段中的<span class="jill"></span>esp0<span class="jill"></span>成员中。通过调用<span class="jill"></span>sysenter<span class="jill"></span>汇编指令从用户态切换到内核态引起的任何特权级别的改变都会导致将这个地址拷贝到<span class="jill"></span>esp<span class="jill"></span>寄存器中。  </span><div id="881d7okunSVL5NiczGT5MK" class="wolai-block wolai-text"><div><span class="inline-wrap">init_tss[cpu].esp0 = next_p-&gt;thread.esp0;  </span></div></div></li><li id="x8rj8i8D3ApcechkYx6WkT"><div class="marker"></div><span class="inline-wrap">将新进程的线程本地存储（TLS）段加载到当前<span class="jill"></span>CPU<span class="jill"></span>的<span class="jill"></span>GDT<span class="jill"></span>中。3<span class="jill"></span>个段选择器存储在进程描述符的<span class="jill"></span>tls_array<span class="jill"></span>数组中。  </span><div id="qiu5LSuVAAXJkSVRewj2jW" class="wolai-block wolai-text"><div><span class="inline-wrap">cpu_gdt_table[cpu][6] = next_p-&gt;thread.tls_array[0];  </span></div></div><div id="2HaQsdohQn2F6iFx4cRGvD" class="wolai-block wolai-text"><div><span class="inline-wrap">cpu_gdt_table[cpu][7] = next_p-&gt;thread.tls_array[1];  </span></div></div><div id="v3XTQhirMzVATxVmoccfjm" class="wolai-block wolai-text"><div><span class="inline-wrap">cpu_gdt_table[cpu][8] = next_p-&gt;thread.tls_array[2];  </span></div></div></li><li id="vWwb3mVDb3cngtCf6xEWhA"><div class="marker"></div><span class="inline-wrap">存储<span class="jill"></span>fs<span class="jill"></span>和<span class="jill"></span>gs<span class="jill"></span>段寄存器的内容到旧进程的<span class="jill"></span>prev_p-&gt;thread.fs<span class="jill"></span>和<span class="jill"></span>prev_p-&gt;thread.gs<span class="jill"></span>中。汇编指令如下：  </span><div id="poQ36SzxNN8PjNwSSHVkBp" class="wolai-block wolai-text"><div><span class="inline-wrap">movl %fs, 40(%esi)  </span></div></div><div id="6FJDeZgbW3Vh8sP6mrVYns" class="wolai-block wolai-text"><div><span class="inline-wrap">movl %gs, 44(%esi)  </span></div></div><div id="9VsFGXYpXFovtB1Z2iVcd7" class="wolai-block wolai-text"><div><span class="inline-wrap">寄存器<span class="jill"></span>esi<span class="jill"></span>指向<span class="jill"></span>prev_p-&gt;thread<span class="jill"></span>结构。gs<span class="jill"></span>寄存器用来存放<span class="jill"></span>TLS<span class="jill"></span>段的地址。fs<span class="jill"></span>寄存器实际上<span class="jill"></span>windows<span class="jill"></span>使用。</span></div></div></li><li id="cujXLvRQ5MC2QX6m9K1Vv4"><div class="marker"></div><span class="inline-wrap">加载新进程的<span class="jill"></span>fs<span class="jill"></span>或<span class="jill"></span>gs<span class="jill"></span>寄存器内容。数据来源是新进程的<span class="jill"></span>thread_struct<span class="jill"></span>描述符中对应的值。汇编语言如下：  </span><div id="oUfqfDe9CEibg6KcXhnp2V" class="wolai-block wolai-text"><div><span class="inline-wrap">movl 40(%ebx),%fs  </span></div></div><div id="rLMjRjZwDHDdWhYcTn8N4D" class="wolai-block wolai-text"><div><span class="inline-wrap">movl 44(%ebx),%gs  </span></div></div><div id="dvbDdPsSFmKnW6VkSrR5hN" class="wolai-block wolai-text"><div><span class="inline-wrap">ebx<span class="jill"></span>寄存器指向<span class="jill"></span>next_p-&gt;thread<span class="jill"></span>结构。</span></div></div></li><li id="p2T51SrEBgCfvYGW8bERcF"><div class="marker"></div><span class="inline-wrap">载入新进程的调式寄存器中的信息。  </span><div id="f39tW5dr9HDdjSKnpXSkzC" class="wolai-block wolai-text"><div><span class="inline-wrap">if (next_p-&gt;thread.debugreg[7]){  </span></div></div><div id="eaihHSht9hPzYRCfkt6Sm" class="wolai-block wolai-text"><div><span class="inline-wrap">loaddebug(&amp;next_p-&gt;thread, 0);  </span></div></div><div id="uN17RMbGG5n6QJ8vbTGJi8" class="wolai-block wolai-text"><div><span class="inline-wrap">loaddebug(&amp;next_p-&gt;thread, 1);  </span></div></div><div id="kMJ1jPF6wRKk6J4JN2rCVw" class="wolai-block wolai-text"><div><span class="inline-wrap">loaddebug(&amp;next_p-&gt;thread, 2);  </span></div></div><div id="th1GmhJsFQNTSQ921bBYL6" class="wolai-block wolai-text"><div><span class="inline-wrap">loaddebug(&amp;next_p-&gt;thread, 3);  </span></div></div><div id="iUKezw715f26fAZytmQ65U" class="wolai-block wolai-text"><div><span class="inline-wrap">/* no 4 and 5 */  </span></div></div><div id="4K9GAe1L3RDbZSMDZnSy7X" class="wolai-block wolai-text"><div><span class="inline-wrap">loaddebug(&amp;next_p-&gt;thread, 6);  </span></div></div><div id="tX1ZLWs971sz9hGiXcw9Bq" class="wolai-block wolai-text"><div><span class="inline-wrap">loaddebug(&amp;next_p-&gt;thread, 7);  </span></div></div><div id="jCmjCpGpbCtJrTyDJu6zpK" class="wolai-block wolai-text"><div><span class="inline-wrap">}  </span></div></div></li><li id="wbj4hNGfDhboKMvjZt5q18"><div class="marker"></div><span class="inline-wrap">更新<span class="jill"></span>TSS<span class="jill"></span>中的<span class="jill"></span>I/O<span class="jill"></span>权限位（如果有必要的话）。也就是如果新旧进程对<span class="jill"></span>I/O<span class="jill"></span>访问有自己特殊的要求的话就需要更改。  </span><div id="teUY3NwomTxATdNM7PvmKm" class="wolai-block wolai-text"><div><span class="inline-wrap">if (prev_p-&gt;thread.io_bitmap_ptr || next_p-&gt;thread.io_bitmap_ptr)  </span></div></div><div id="7u7gvDgfPMioepXMdTReYw" class="wolai-block wolai-text"><div><span class="inline-wrap">handle_io_bitmap(&amp;next_p-&gt;thread, &amp;init_tss[cpu]);  </span></div></div></li><li id="oJyPeMjZoTm6V6pjt8X2iU"><div class="marker"></div><span class="inline-wrap"><code>__switch_to()</code></span><span class="inline-wrap">函数结束。  </span><div id="266rGt98UzfdpG8jGCxnwk" class="wolai-block wolai-text"><div><span class="inline-wrap">return prev_p;  </span></div></div><div id="u5rZrkHX1VdpkT4PX4Bcf6" class="wolai-block wolai-text"><div><span class="inline-wrap">相应的汇编语言就是：  </span></div></div><div id="wkooCMAf6UVbj2o6E3vCjk" class="wolai-block wolai-text"><div><span class="inline-wrap">movl %edi,%eax  </span></div></div><div id="cVfwbY77bJW8PsCq3jx1Hs" class="wolai-block wolai-text"><div><span class="inline-wrap">ret</span></div></div></li></ol><div id="oSee1JoXdGu35hBN9sXNPX" class="wolai-block wolai-text"><div><span class="inline-wrap">因为<span class="jill"></span>switch_to<span class="jill"></span>总是假设<span class="jill"></span>eax<span class="jill"></span>寄存器保存旧进程的进程描述符的地址。所以，这里把<span class="jill"></span>prev_p<span class="jill"></span>变量再次写入到<span class="jill"></span>eax<span class="jill"></span>寄存器中。</span></div></div><div id="9uTGEERxVR2wbJWEuKJzyv" class="wolai-block wolai-text"><div><span class="inline-wrap">ret<span class="jill"></span>指令把栈上要返回的地址写入到<span class="jill"></span>eip<span class="jill"></span>寄存器中。其实，栈上的返回地址就是标签为</span><span class="inline-wrap"><code>1</code></span><span class="inline-wrap">处的指令地址，这是由<span class="jill"></span>switch_to<span class="jill"></span>压栈的。如果新进程从来没挂起过，因为是第一次执行，然后就会跳转到<span class="jill"></span>ret_from_fork()函数返回的起始地址处（这部分等讲进程的创建时再细说）。至此，完成了进程的切换。</span></div></div><div id="joNn9b9Jnno4sY9o5Puvrt" class="wolai-bookmark wolai-block"><a href="https://juejin.cn/post/7043252167687274533#heading-11">Linux 内核源码分析之进程调度的逻辑 - 掘金</a><div class="info-box"><div class="text-pane"><div data-title="Linux 内核源码分析之进程调度的逻辑 - 掘金"></div><div data-desc="操作系统理论中，进程调度分为选择优先级较高的进程以及切换寄存器，Linux 内核中是如何实现操作系统理论的？"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png&quot;)"></div><div data-hostname="juejin.cn"></div></div></div><div class="preview-pane"></div></div></div><div id="rJV3eENiuVv6qWejAriRck" class="wolai-bookmark wolai-block"><a href="https://zhuanlan.zhihu.com/p/533447707">如何理解Linux内核下的进程切换</a><div class="info-box"><div class="text-pane"><div data-title="如何理解Linux内核下的进程切换"></div><div data-desc="好文推荐： 嵌入式Rom：一文读懂Linux内核内存域管理 玩转腾讯首发Linux内核源码《嵌入式开发笔记》，也许能帮到你哦浅谈Linux 内核无线子系统（建议收藏） 一文读懂Linux内核磁盘文件系统 进程通信的7种方式1 进…"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png&quot;)"></div><div data-hostname="zhuanlan.zhihu.com"></div></div></div><div class="preview-pane" style="background-image: url(https://picx.zhimg.com/v2-e3c48b5f4e14e3f8f71296ed55b8bd14_720w.jpg?source=172ae18b)"></div></div></div><code-block id="au7AMJQLz13WBqSvmkHUqo" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre>#define <span class="token function">switch_to</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">,</span> last<span class="token punctuation">)</span>                             \
<span class="token keyword control-flow">do</span> <span class="token punctuation">{</span>                                                            \
    <span class="token comment">/*
     * 进程切换可能会改变所有的寄存器，所以我们通过未使用的输出变量显式地修改它们。
     * EAX和EBP没有被列出，是因为EBP是为当前进程访问显式地保存和恢复的寄存器，
     * 而EAX将会作为函数__switch_to()的返回值。
     */</span>
    unsigned long ebx<span class="token punctuation">,</span> ecx<span class="token punctuation">,</span> edx<span class="token punctuation">,</span> esi<span class="token punctuation">,</span> edi<span class="token punctuation">;</span>                      \
                                                                  \
    asm <span class="token function">volatile</span><span class="token punctuation">(</span><span class="token string">"pushfl\n\t"</span>               <span class="token comment">/* save    flags */</span> \
             <span class="token string">"pushl %%ebp\n\t"</span>              <span class="token comment">/* save    EBP   */</span> \
             <span class="token string">"movl %%esp,%[prev_sp]\n\t"</span>    <span class="token comment">/* save    ESP   */</span> \
             <span class="token string">"movl %[next_sp],%%esp\n\t"</span>    <span class="token comment">/* restore ESP   */</span> \
             <span class="token string">"movl $1f,%[prev_ip]\n\t"</span>      <span class="token comment">/* save    EIP   */</span> \
             <span class="token string">"pushl %[next_ip]\n\t"</span>         <span class="token comment">/* restore EIP   */</span> \
             __switch_canary                                    \
             __retpoline_fill_return_buffer                     \
             <span class="token string">"jmp __switch_to\n"</span>            <span class="token comment">/* regparm call  */</span> \
             <span class="token string">"1:\t"</span>                                             \
             <span class="token string">"popl %%ebp\n\t"</span>               <span class="token comment">/* restore EBP   */</span> \
             <span class="token string">"popfl\n"</span>                      <span class="token comment">/* restore flags */</span> \
                                                                \
             <span class="token comment">/* 输出参数 */</span>                                     \
             <span class="token operator">:</span> <span class="token punctuation">[</span>prev_sp<span class="token punctuation">]</span> <span class="token string">"=m"</span> <span class="token punctuation">(</span>prev<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">.</span><span class="token property-access">sp</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                \
               <span class="token punctuation">[</span>prev_ip<span class="token punctuation">]</span> <span class="token string">"=m"</span> <span class="token punctuation">(</span>prev<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">.</span><span class="token property-access">ip</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                \
               <span class="token string">"=a"</span> <span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">,</span>                                     \
                                                                \
               <span class="token comment">/* 列出所有可能会修改的寄存器  */</span>                \
               <span class="token string">"=b"</span> <span class="token punctuation">(</span>ebx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=c"</span> <span class="token punctuation">(</span>ecx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=d"</span> <span class="token punctuation">(</span>edx<span class="token punctuation">)</span><span class="token punctuation">,</span>              \
               <span class="token string">"=S"</span> <span class="token punctuation">(</span>esi<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=D"</span> <span class="token punctuation">(</span>edi<span class="token punctuation">)</span>                           \
                                                                \
               __switch_canary_oparam                           \
                                                                \
               <span class="token comment">/* 输入参数 */</span>                                   \
             <span class="token operator">:</span> <span class="token punctuation">[</span>next_sp<span class="token punctuation">]</span>  <span class="token string">"m"</span> <span class="token punctuation">(</span>next<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">.</span><span class="token property-access">sp</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                \
               <span class="token punctuation">[</span>next_ip<span class="token punctuation">]</span>  <span class="token string">"m"</span> <span class="token punctuation">(</span>next<span class="token operator">-</span><span class="token operator">></span>thread<span class="token punctuation">.</span><span class="token property-access">ip</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                \
                                                                \
               <span class="token comment">/* 为函数__switch_to()设置寄存器参数 */</span>          \
               <span class="token punctuation">[</span>prev<span class="token punctuation">]</span>     <span class="token string">"a"</span> <span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">,</span>                           \
               <span class="token punctuation">[</span>next<span class="token punctuation">]</span>     <span class="token string">"d"</span> <span class="token punctuation">(</span>next<span class="token punctuation">)</span>                            \
                                                                \
               __switch_canary_iparam                           \
                                                                \
             <span class="token operator">:</span> <span class="token comment">/* reloaded segment registers */</span>                 \
            <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                          \
<span class="token punctuation">}</span> <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></div></code-block><h2 id="t9BnkXu7JxxtVZEfATVvqF" class="wolai-block"><span class="inline-wrap">Linux<span class="jill"></span>的<span class="jill"></span>fork<span class="jill"></span>是如何实现的</span></h2><div id="stEgyEnWPr2tzYXvzJPXuW" class="wolai-block wolai-text"><div><span class="inline-wrap">Linux<span class="jill"></span>的<span class="jill"></span>fork<span class="jill"></span>函数是通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。¹² fork<span class="jill"></span>函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。² fork<span class="jill"></span>底层实现机制：Linux<span class="jill"></span>中实现为调用<span class="jill"></span>clone<span class="jill"></span>函数，然后为<span class="jill"></span>do_fork，再然后<span class="jill"></span>copy_process ()复制进程（复制相应数据结构例如:内核栈、thread_info、task_struct），然后设置子进程描述符内一些成员初始值，再设置子进程状态为阻塞，保证其不运行，分配<span class="jill"></span>PID；最后再从父进程中拷贝其他信息例如:打开的文件、文件系统信息。²

源: 与必应的对话， 2023/4/5
(1) 论<span class="jill"></span>fork()函数与<span class="jill"></span>Linux<span class="jill"></span>中的多线程编程 - 知乎. </span><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/130873706"><span>https://zhuanlan.zhihu.com/p/130873706</span></a></span><span class="inline-wrap">.
(2) linux--fork()函数详解及底层实现机制_DianaCody<span class="jill"></span>的博客-CSDN<span class="jill"></span>博客. </span><span class="inline-wrap"><a href="https://blog.csdn.net/dianacody/article/details/22401475"><span>https://blog.csdn.net/dianacody/article/details/22401475</span></a></span><span class="inline-wrap">.
(3) fork（）函数的底层实现原理_fork<span class="jill"></span>机制_Shining-LY<span class="jill"></span>的博客-CSDN<span class="jill"></span>博客. </span><span class="inline-wrap"><a href="https://blog.csdn.net/qq_37964547/article/details/81482001"><span>https://blog.csdn.net/qq_37964547/article/details/81482001</span></a></span><span class="inline-wrap">.
(4) Linux<span class="jill"></span>中<span class="jill"></span>fork()函数详解_生命沉思者的博客-CSDN<span class="jill"></span>博客. </span><span class="inline-wrap"><a href="https://blog.csdn.net/kxjrzyk/article/details/81603049"><span>https://blog.csdn.net/kxjrzyk/article/details/81603049</span></a></span><span class="inline-wrap">.
(5) 十九. fork<span class="jill"></span>的原理及实现 - 知乎. </span><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/36872365"><span>https://zhuanlan.zhihu.com/p/36872365</span></a></span><span class="inline-wrap">.
(6) Linux 高级编程 - fork 进程控制 - 知乎. </span><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/84342331"><span>https://zhuanlan.zhihu.com/p/84342331</span></a></span><span class="inline-wrap">.</span></div></div><h2 id="hRYgHDAWy597d3TmMouDw7" class="wolai-block"><span class="inline-wrap">进程和线程有什么区别</span></h2><div id="j8xioQuWsTFGddxLL5iXMq" class="wolai-block wolai-text"><div><span class="inline-wrap">进程和线程都是操作系统中的并发执行的基本单位，但是它们之间有很大的区别。进程是操作系统资源分配的基本单位，每启动一个进程都需要向操作系统索要运行资源，默认一个进程只有一个线程，线程是依附在进程里面的。线程是<span class="jill"></span>cpu<span class="jill"></span>调度的基本单位，通过线程去执行进程中代码，线程是执行代码的分支。¹²

源: 与必应的对话， 2023/4/5
(1) 线程 、进程、协程 三者区别 - 知乎. </span><span class="inline-wrap"><a href="https://bing.com/search?q=进程和线程的区别"><span>https://bing.com/search?q=进程和线程的区别</span></a></span><span class="inline-wrap">.
(2) 线程 、进程、协程 三者区别 - 知乎. </span><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/101230252"><span>https://zhuanlan.zhihu.com/p/101230252</span></a></span><span class="inline-wrap">.
(3) Python<span class="jill"></span>多进程(process)和多线程(thread)的区别_python<span class="jill"></span>多线程和多进程的区别_rs<span class="jill"></span>勿忘初心的博客-CSDN<span class="jill"></span>博客. </span><span class="inline-wrap"><a href="https://blog.csdn.net/sinat_33718563/article/details/119716436"><span>https://blog.csdn.net/sinat_33718563/article/details/119716436</span></a></span><span class="inline-wrap">.
(4) 进程与线程的联系和区别？ - 简书. </span><span class="inline-wrap"><a href="https://www.jianshu.com/p/a4fa4edbeb8a"><span>https://www.jianshu.com/p/a4fa4edbeb8a</span></a></span><span class="inline-wrap">.
(5) 线程和进程的区别是什么？ - 知乎. </span><span class="inline-wrap"><a href="https://www.zhihu.com/question/25532384"><span>https://www.zhihu.com/question/25532384</span></a></span><span class="inline-wrap">.
(6) 面试必考 | 进程和线程的区别 - 知乎. </span><span class="inline-wrap"><a href="https://zhuanlan.zhihu.com/p/114453309"><span>https://zhuanlan.zhihu.com/p/114453309</span></a></span><span class="inline-wrap">.</span></div></div><h2 id="7CmpNfGd4T5g3BZzW11Pch" class="wolai-block"><span class="inline-wrap">操作系统为什么引入进程？</span></h2><div id="6smuVZ2KaDTmGy8p31YL7a" class="wolai-block wolai-text"><div><span class="inline-wrap">操作系统引入进程的原因是为了使程序在多道程序环境下能并发执行，并能对并发执行的程序加以控制和描述，从而实现对计算机系统的有效管理和调度<span class="jill"></span>¹。

源: 与必应的对话， 2023/4/5
(1) 在操作系统中为什么要引入进程这一概念-常见问题-PHP<span class="jill"></span>中文网. </span><span class="inline-wrap"><a href="https://www.php.cn/faq/475561.html"><span>https://www.php.cn/faq/475561.html</span></a></span><span class="inline-wrap">.
(2) 在操作系统中为什么要引入进程概念？_百度知道. </span><span class="inline-wrap"><a href="https://zhidao.baidu.com/question/403649373.html"><span>https://zhidao.baidu.com/question/403649373.html</span></a></span><span class="inline-wrap">.
(3) 操作系统为什么要引入进程？ - 知乎. </span><span class="inline-wrap"><a href="https://www.zhihu.com/question/47877636"><span>https://www.zhihu.com/question/47877636</span></a></span><span class="inline-wrap">.
(4) 操作系统学习笔记（day3）进程状态及转换_引入创建、终止状态的原因_RaspberryfC.的博客-CSDN<span class="jill"></span>博客. </span><span class="inline-wrap"><a href="https://blog.csdn.net/weixin_44952214/article/details/105877476"><span>https://blog.csdn.net/weixin_44952214/article/details/105877476</span></a></span><span class="inline-wrap">.</span></div></div><div id="q7uMUvWddH6MN6Bavsa5bP" class="wolai-block wolai-text"><div></div></div></article><footer></footer></body></html>