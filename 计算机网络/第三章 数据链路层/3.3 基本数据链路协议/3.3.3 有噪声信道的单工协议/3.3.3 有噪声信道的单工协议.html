<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>3.3.3 有噪声信道的单工协议 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div data-symbol="⭐" class="icon"></div></div><div data-title="3.3.3 有噪声信道的单工协议" class="main-title"></div></div></header><article><h2 id="7rimMhMC7Y76MRCfsUMygu" class="wolai-block"><span class="inline-wrap">条件：</span></h2><div id="mkVqr1RfEi8AfLcbKUa4yw" class="wolai-block wolai-text"><div><span class="inline-wrap">我们考虑一个会出错的通信信道，可能会发生</span></div></div><ul class="wolai-block"><li id="28Z7V3T1NDaKCh3N44AHYg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">帧被损坏且被检验和检查出来</span></li><li id="onVQ1PsEDuz9ScN1HHz8if"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">帧被损坏但校验和仍正确（向网络层提交了错误的分组）</span></li><li id="xcd97stBCkQeNkzdN12mhy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">帧完全丢失</span></li></ul><div id="cncqSioRJ5mvVwngAo6D3H" class="wolai-block wolai-text"><div><span class="inline-wrap">所以我们把</span><span class="inline-wrap"><a href="../3.3.2%20%E6%97%A0%E9%94%99%E4%BF%A1%E9%81%93%E4%B8%8A%E7%9A%84%E5%8D%95%E5%B7%A5%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE/3.3.2%20%E6%97%A0%E9%94%99%E4%BF%A1%E9%81%93%E4%B8%8A%E7%9A%84%E5%8D%95%E5%B7%A5%E5%81%9C-%E7%AD%89%E5%8D%8F%E8%AE%AE.html#fxEu4QLsvwzaDPXffSjw4G" class="wolai-bi-link"><span class="embed-page">3.3.2 无错信道上的单工停-等协议</span></a></span><span class="inline-wrap">上的条件进一步加强为：</span></div></div><ul class="wolai-block"><li id="9igxxC2XuHK2vCuhdhszC8"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">数据单向传输（实际上会变成半双工）</span></li><li id="hdomvuey63ar3tgCpVnThN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><del>数据处理时间忽略不计，可用的缓存空间无限大（无流控）</del></span></li><li id="doG7ojNwRBoHeRtina2KNd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><del>通信永远不会损坏或丢失帧（无噪声、</del></span><span class="inline-wrap"><a href="../../3.1.3%20%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%A7%E5%88%B6/3.1.3%20%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%A7%E5%88%B6.html#pSapsT5xCy4HYy21NZxufR" class="wolai-bi-link"><span class="embed-page">3.1.3 错误的控制<del></del></span></a></span><span class="inline-wrap"><del>）</del></span></li></ul><h2 id="efAGb6QtDTYfW8MWwWp9Ti" class="wolai-block"><span class="inline-wrap">错误控制</span></h2><div id="9Sb79yVjSBvZFfmethwufo" class="wolai-block wolai-text"><div><span class="inline-wrap">在</span><span class="inline-wrap"><a href="../../3.1.3%20%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%A7%E5%88%B6/3.1.3%20%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%A7%E5%88%B6.html#pSapsT5xCy4HYy21NZxufR" class="wolai-bi-link"><span class="embed-page">3.1.3 错误的控制</span></a></span><span class="inline-wrap">中我们学习到了定时器和序列号的概念</span></div></div><div class="block-ref"><div class="decorator"></div><div id="koZFGBWcZZDwvzimZiQyYW" class="wolai-block wolai-text"><div><span class="inline-wrap">最简单的方法：让接收方发送反馈信息</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="8jtwhoZyayBphNmUqwAEj4" class="wolai-block wolai-text"><div><span class="inline-wrap">进阶方法：设置一个定时器 如果反馈信息丢失 就可以自动重发</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="7a7xZMgRzvXBsTiZrN79ag" class="wolai-block wolai-text"><div><span class="inline-wrap">进进阶方法：双方都初始化一个序列号，以防定时器导致的重复发送帧</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="eo7UpfJ6bjnEoxc66aCnzz" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image.png" style="width: 182px"/></figure></div></div><div id="tUm7HJww1wtwAvEmCHC1dY" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="4UTjZ42gcSZxLZKXfHjALw" class="wolai-block wolai-text"><div><span class="inline-wrap">让我们进一步来思考为什么要这么做。</span></div></div><h3 id="8YxygDjGKLGXkSp45GKM7A" class="wolai-block"><span class="inline-wrap">定时器</span></h3><div id="nNsDo12DkZaWhN4yYHqVBD" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_1.png" style="width: 100%"/></figure></div><div class="block-ref"><div class="decorator"></div><div id="m5oT1juy9t6LMJ92P7SZUH" class="wolai-block wolai-text"><div><span class="inline-wrap">但其实，数据分组在传输过程中并不会那么一帆风顺，数据分组有可能在半路上遇到一个已经满了的路由器等情况，此时路由器会毫不犹豫地丢失该分组，如此便会产生数据分组被丢失，发送方等不到接收方的<span class="jill"></span>ACK<span class="jill"></span>或者<span class="jill"></span>NAK。</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="7Cid6f4QyqR2a1otTiXXLv" class="wolai-block wolai-text"><div><span class="inline-wrap">所以，我们需要给每次的数据分组的传输提供一个超时计时器，若到了超时计时器所设置的重传时间，而发送方仍收不到接收方的<span class="jill"></span>ACK<span class="jill"></span>或<span class="jill"></span>NAK，则重传原来的数据分组。</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="98CiCaRPAzruCdTGvCTD9m" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_2.png" style="width: 100%"/></figure></div></div><h3 id="4rGxvVMHNCEinMSrbiXGHW" class="wolai-block"><span class="inline-wrap">定时器法的一个致命错误：帧被重复接收</span></h3><div id="vp8aLthXUJMtJpSeznGkfh" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_3.png" style="width: 100%"/></figure></div><h3 id="mE6JZHiJduuyYwwPiAkaHN" class="wolai-block"><span class="inline-wrap">序列号</span></h3><div id="6gu31ur8C1eC77zFpmzfmu" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_4.png" style="width: 100%"/></figure></div><div class="block-ref"><div class="decorator"></div><div id="pHcpBTKipmHM9f5rxfPhfK" class="wolai-block wolai-text"><div><span class="inline-wrap">在传输的过程中接收方的确认可能会丢失或者迟到。这样就会导致发送方误判重新传一个重复的数据，而接受方也无法判断这个数据是不是接受过。或者来了一个重复的确认不能判断这个<span class="jill"></span>ACK<span class="jill"></span>是哪个消息的。</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="4kfLaNnJ9sziPwepKwpn96" class="wolai-block wolai-text"><div><span class="inline-wrap">所以我们需要给发送方发送的消息和接受方发送的<span class="jill"></span>ACK<span class="jill"></span>进行编号使他们相互对应来避免这些问题的发生。</span></div></div></div><div class="block-ref"><div class="decorator"></div><div id="kCdjBQ9NYRxk23KyPdvHoG" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_5.png" style="width: 718px"/></figure></div></div><h4 id="5W2fhFBSyV7G7jeCbtoYYQ" class="wolai-block"><span class="inline-wrap">一位序列号足够</span></h4><aside id="qxX8Zs3wPTtxAYqw7jEkQT" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">由于需要区分新、旧两个帧，因此要使用<span class="jill"></span>1<span class="jill"></span>比特的帧序号。</span></aside><details id="eSv1gtMpweTmbEmnMD9MbR" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">why?</span></summary><div id="u1iHFpHMszjifv1XfzLvGY" class="wolai-block"><figure class="wolai-left" style="width: 100%"><img src="media/image_6.png" style="width: 100%"/></figure></div></details><div id="ib5syhtJWki4XTNWQV81fv" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_7.png" style="width: 100%"/></figure></div><div id="6FEqfxM22fDtBXeZzNmr1C" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_8.png" style="width: 100%"/></figure></div><h2 id="fUPVxbLHW9jutn3C1g88qU" class="wolai-block"><span class="inline-wrap">代码</span></h2><aside id="nPrevRrC7NFCDokAGAEG7u" class="bg-cultured wolai-block"><div data-symbol="⭐" class="icon"></div><span class="inline-wrap">需要过代码</span></aside><code-block id="sxQ6ke1XgayzFVJaCoks3S" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre><span class="token comment">/* Protocol 3 (par) allows unidirectional data flow over an unreliable channel. */</span>

#define <span class="token constant">MAX_SEQ</span> <span class="token number">1</span>  <span class="token comment">/* must be 1 for protocol 3 */</span>
typedef <span class="token keyword">enum</span>  <span class="token punctuation">{</span>frame_arrival<span class="token punctuation">,</span> cksum_err<span class="token punctuation">,</span> timeout<span class="token punctuation">}</span> event_type<span class="token punctuation">;</span>
#include <span class="token string">"protocol.h"</span>
</pre></div></code-block><h3 id="kpy2uy3WF4apC9cDEDVt96" class="wolai-block"><span class="inline-wrap">void sender3(void)</span></h3><h4 id="9DBd1Z8rYcGoCH48WwqkZy" class="wolai-block"><span class="inline-wrap">序列号初始化</span></h4><div id="gQB43AkKby4NUHnBPqsRs7" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_9.png" style="width: 100%"/></figure></div><h4 id="jc139eLh2fHiKSP1BpQ5Vv" class="wolai-block"><span class="inline-wrap">启动/重置定时器</span></h4><div id="jFzwzH5UmJLrPWim25g8Ba" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_10.png" style="width: 100%"/></figure></div><div id="sDZU2FB3eA3VXqGmLaMM6B" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_11.png" style="width: 100%"/></figure></div><h4 id="5nFpKpszCdfMxy1aJpMUGY" class="wolai-block"><span class="inline-wrap">三种可能的事件</span></h4><div id="cRMMTDLxNwEYX9D3743vhZ" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="media/image_12.png" style="width: 100%"/></figure></div><code-block id="nUe8Pk8oaHZzhsPC2vyn6k" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre><span class="token keyword">void</span> <span class="token function">sender3</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">void</span></span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  seq_nr next_frame_to_send<span class="token punctuation">;</span>  <span class="token comment">/* seq number of next outgoing frame */</span>
  frame s<span class="token punctuation">;</span>  <span class="token comment">/* scratch variable */</span>
  packet buffer<span class="token punctuation">;</span>  <span class="token comment">/* buffer for an outbound packet */</span>
  event_type event<span class="token punctuation">;</span>

  next_frame_to_send <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">/* initialize outbound sequence numbers */</span>
  <span class="token function">from_network_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* fetch first packet */</span>
  <span class="token comment">// 无条件发送第一帧</span>
  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s<span class="token punctuation">.</span><span class="token property-access">info</span> <span class="token operator">=</span> buffer<span class="token punctuation">;</span>  <span class="token comment">/* construct a frame for transmission */</span>
        s<span class="token punctuation">.</span><span class="token property-access">seq</span> <span class="token operator">=</span> next_frame_to_send<span class="token punctuation">;</span>  <span class="token comment">/* insert sequence number in frame */</span>
        <span class="token function">to_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* send it on its way */</span>
        <span class="token function">start_timer</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">seq</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* if answer takes too long, time out */</span>
        <span class="token comment">// 设置定时器 以防无限的等待</span>
        <span class="token comment">// 这里结合了 校验编码 对发送帧编号 定时器启动 删减跳过的比较多</span>
        <span class="token function">wait_for_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* frame_arrival, cksum_err, timeout */</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> frame_arrival<span class="token punctuation">)</span> <span class="token comment">// 确认帧完好</span>
        <span class="token punctuation">{</span>
                <span class="token function">from_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* get the acknowledgement */</span>
                <span class="token comment">// 取出确认帧 这里的确认帧不之前是一个哑帧了，而是含有s.ack</span>
                <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">ack</span> <span class="token operator">==</span> next_frame_to_send<span class="token punctuation">)</span> <span class="token comment">// 确认序列号</span>
                <span class="token punctuation">{</span>
                        <span class="token function">stop_timer</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token property-access">ack</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//关闭定时器</span>
                        <span class="token function">from_network_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* get the next one to send */</span>
                        <span class="token comment">// 准备下一帧</span>
                        <span class="token function">inc</span><span class="token punctuation">(</span>next_frame_to_send<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* invert next_frame_to_send */</span>
                        <span class="token comment">// 序列号++</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//else 就不停的等</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block><h3 id="qABnAGjAnTm7uFEWtkivyo" class="wolai-block"><span class="inline-wrap">void receiver3(void)</span></h3><code-block id="qYxSGWUZrNLeCHa7big94M" class="wolai-block"><div class="wolai-pre"><div data-lang="C++" class="marker"></div><pre><span class="token keyword">void</span> <span class="token function">receiver3</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">void</span></span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  seq_nr frame_expected<span class="token punctuation">;</span>
  frame r<span class="token punctuation">,</span> s<span class="token punctuation">;</span>
  event_type event<span class="token punctuation">;</span>

  frame_expected <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">wait_for_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* possibilities: frame_arrival, cksum_err */</span>
        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>event <span class="token operator">==</span> frame_arrival<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">/* A valid frame has arrived. */</span>
                <span class="token function">from_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* go get the newly arrived frame */</span>
                <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token property-access">seq</span> <span class="token operator">==</span> frame_expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">/* This is what we have been waiting for. */</span>
                        <span class="token function">to_network_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">.</span><span class="token property-access">info</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* pass the data to the network layer */</span>
                        <span class="token function">inc</span><span class="token punctuation">(</span>frame_expected<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* next time expect the other sequence nr */</span>
                <span class="token punctuation">}</span>
                s<span class="token punctuation">.</span><span class="token property-access">ack</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> frame_expected<span class="token punctuation">;</span>  <span class="token comment">/* tell which frame is being acked */</span>
                <span class="token function">to_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* only the ack field is use */</span>
                <span class="token comment">// 发送确认帧</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre></div></code-block></article><footer></footer></body></html>