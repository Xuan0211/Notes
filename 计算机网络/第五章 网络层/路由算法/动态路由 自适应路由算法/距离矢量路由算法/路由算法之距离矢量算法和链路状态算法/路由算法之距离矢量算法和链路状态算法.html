<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../../css/wolai.css"/><title>路由算法之距离矢量算法和链路状态算法 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="路由算法之距离矢量算法和链路状态算法" class="main-title"></div></div></header><article><div id="2vbr1jgJjaxFX8Bevzqscf" class="wolai-block wolai-text"><div><span class="inline-wrap">我们之前说了，</span><span class="inline-wrap"><a href="https://so.csdn.net/so/search?q=%E8%B7%AF%E7%94%B1%E5%99%A8&amp;spm=1001.2101.3001.7020"><span>路由器</span></a></span><span class="inline-wrap">需要对于每一对端端节点都要寻找出一个最佳的路径，比如说最小链路成本的路径。路由算法就是通过自己到相邻节点之间的信息来计算出自己到目的地址的最佳出境线路是哪一条，进而进行转发的一类算法。具有代表性的就是距离矢量算法和链路状态算法。</span></div></div><div id="hVKqHftnY8udF4QeExHZo9" class="wolai-block wolai-text"><div><span class="inline-wrap">距离矢量算法的特点是：</span></div></div><div id="9k47RM2ZS5HXHcZgdiu8Lz" class="wolai-block wolai-text"><div><span class="inline-wrap">1.分布的<span class="jill"></span>  每个节点接收来自与其直接邻接节点的路由信息，并执行路由计算，将计算结果回传给直接邻接的节点</span></div></div><div id="v8cPbmgTkrg9Tw5hTgWhnQ" class="wolai-block wolai-text"><div><span class="inline-wrap">2.迭代的<span class="jill"></span>  计算过程循环进行，直到相邻节点没有可交换的路由信息为止</span></div></div><div id="wsyWCwBrhTQz2mHTeeFu6K" class="wolai-block wolai-text"><div><span class="inline-wrap">3.异步的<span class="jill"></span>  并不要求所有节点相互锁步操作</span></div></div><div id="9G6uaZeRJmYMJ4xijpWMZr" class="wolai-block wolai-text"><div><span class="inline-wrap">距离矢量算法（DV）他会把自己的路由表分享给自己的所有相邻节点，那么这些节点如果发现通过新的路由表自己到其他节点的距离改变了，那么再把自己的更新的路由表发送给自己的周围节点，所以这个过程是迭代的，异步的。</span></div></div><div id="5dXSGbMnwdcvyiuV4vvoTz" class="wolai-block wolai-text"><div><span class="inline-wrap">要想知道距离矢量算法的具体工作原理，首先看一个公式，这也是距离矢量算法的核心：</span></div></div><div id="5mn96VZJuWZ29oJ8qXVbJ2" class="wolai-block wolai-text"><div><span class="inline-wrap">Dx(Y，Z) = c(X，Z) +minw {Dz(Y，w)}  </span></div><div id="rKxgbFTzE3jTB7xV8YXyrk" class="wolai-block wolai-text"><div><span class="inline-wrap">这个公式的含义是：节点<span class="jill"></span>X<span class="jill"></span>经过<span class="jill"></span>Z<span class="jill"></span>到达<span class="jill"></span>Y<span class="jill"></span>的距离= X<span class="jill"></span>到邻居<span class="jill"></span>Z<span class="jill"></span>的距离<span class="jill"></span>+ Z<span class="jill"></span>到<span class="jill"></span>Y<span class="jill"></span>的最短距离（经过<span class="jill"></span>Z<span class="jill"></span>的相邻某一个节点<span class="jill"></span>w），如下图所示，XZ<span class="jill"></span>直接相连。</span></div></div></div><div id="w7LqD5iE7b5hhPKVtpckho" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://img-blog.csdn.net/20180111114811783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuemhlbjc1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" style="width: 507.2px"/></figure></div><div id="7JCHBEiAPCngf9b9qHRM6b" class="wolai-block wolai-text"><div><span class="inline-wrap">所以我们能够根据这个公式计算出每一个节点到其他任意节点的最小距离，并且画出距离矩阵表：</span></div></div><div id="32sxk5Z1LonquP7zopvSq1" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://img-blog.csdn.net/20180111115022267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuemhlbjc1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style="width: 847.2px"/></figure></div><div id="rorowaWEnzrKfZtx8UNp97" class="wolai-block wolai-text"><div><span class="inline-wrap">上面的例子是<span class="jill"></span>ABCDE<span class="jill"></span>五个节点，其中画出的是计算<span class="jill"></span>E<span class="jill"></span>节点对于其他所有节点的距离矩阵。距离矩阵中上面的是<span class="jill"></span>E<span class="jill"></span>节点的所有邻居，侧面的是所有的节点。那么每一行应该是节点<span class="jill"></span>E<span class="jill"></span>经过不同相邻节点到达目标节点的距离的集合，从这里面选择最小的，就是最小距离了。那么这个对应的相邻节点自然就是出境端口。这就是距离矢量算法。</span></div></div><div id="oXgZZqywJY1ga5rQExAjKP" class="wolai-block wolai-text"><div><span class="inline-wrap">距离矢量算法需要维护每个节点经过相邻节点到全部目的地的路径表，当自己发现到别人的路径成本发生变化的时候就计算更新路由表，并且把自己的路由表广播给所有临节点。它也会接收相邻节点发来的路由表更新信息并计算更新自己的路由表，并且将更新的发回去。</span></div></div><div id="ruQWNfsZJopYY6SxHeWNfD" class="wolai-block wolai-text"><div><span class="inline-wrap">距离矢量算法的好处是，任何一个新加入的节点都会很快的和其他节点建立联系，一路一路更新消息传递的快，但是缺点是满收敛，因为你传给我我传给你，收敛地就慢了。与之相对比的是链路状态算法（LS）.</span></div></div><div id="Pc2Jwm5kvatYx8recTpiy" class="wolai-block wolai-text"><div><span class="inline-wrap">在链路状态算法中，每个节点都有完整地</span><span class="inline-wrap"><a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91&amp;spm=1001.2101.3001.7020"><span>网络拓扑</span></a></span><span class="inline-wrap">图，也就是完整的链路信息（距离矢量法只知道和相邻路由的），节点向相邻网络广播自己和邻居的信息，</span><span class="inline-wrap"><b>每当自己也收到这个信息，就用<span class="jill"></span>dijkstra<span class="jill"></span>算法来重新计算路由表。那么重点就是</b></span><span class="inline-wrap"><a href="https://www.wolai.com/seJ8dyf6GQy68ABMYX52G6#seJ8dyf6GQy68ABMYX52G6" class="wolai-bi-link"><span class="embed-page">迪杰斯特拉 Dijkstra</span></a></span><span class="inline-wrap"><b>算法，算法的步骤如下图：</b></span></div></div><div id="sqbGibXPCEP1UhaqaAkzGf" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://img-blog.csdn.net/20180111120406949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuemhlbjc1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style="width: 960.8px"/></figure></div><div id="pcmSJCg6QwmQoVAss8w8qv" class="wolai-block wolai-text"><div><span class="inline-wrap">如果想建立<span class="jill"></span>A<span class="jill"></span>的路由表，每次都把某一个工作节点对于<span class="jill"></span>A<span class="jill"></span>的最小路径相邻节点放在这个集合中，再迭代寻找。例子如下：</span></div></div><div id="ryW276omGzLQKqcxejqphS" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://img-blog.csdn.net/20180111120604951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuemhlbjc1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style="width: 914.4px"/></figure></div><div id="ccKApaDSVQWNoYbq1bZ5Cp" class="wolai-block wolai-text"><div><span class="inline-wrap">第<span class="jill"></span>0<span class="jill"></span>步，这个集合<span class="jill"></span>N<span class="jill"></span>只有<span class="jill"></span>A<span class="jill"></span>一个元素，横排里面<span class="jill"></span>D(B)代表这个节点到<span class="jill"></span>A<span class="jill"></span>的最短距离，P(B)B<span class="jill"></span>代表到<span class="jill"></span>A<span class="jill"></span>的上一跳是那个节点。0<span class="jill"></span>步中发现到<span class="jill"></span>A<span class="jill"></span>的最小节点是<span class="jill"></span>D，因为距离是<span class="jill"></span>1，那么进入第一步<span class="jill"></span>step1，把<span class="jill"></span>D<span class="jill"></span>放入集合<span class="jill"></span>N,下一步从<span class="jill"></span>D<span class="jill"></span>的相邻节点里面找，就列出来了第二排，BCE<span class="jill"></span>三个点的数值。F<span class="jill"></span>因为还没有探索到，所以仍然记为无穷。第一步做好了，发现<span class="jill"></span>BE<span class="jill"></span>都距离<span class="jill"></span>A<span class="jill"></span>为<span class="jill"></span>2，都是最小的，所以就随机取一个，把<span class="jill"></span>D<span class="jill"></span>放在集合<span class="jill"></span>N<span class="jill"></span>里面，第三步<span class="jill"></span>step3<span class="jill"></span>就是对<span class="jill"></span>E<span class="jill"></span>的相邻节点找到<span class="jill"></span>A<span class="jill"></span>的最小距离节点然后放在集合<span class="jill"></span>N<span class="jill"></span>里面，以此类推直到所有的节点都在<span class="jill"></span>N<span class="jill"></span>里面即可，图中画红圈的，按照时间顺序分别是<span class="jill"></span>ADEBCF<span class="jill"></span>一次进入集合<span class="jill"></span>N。 所以最短路径有了，那么下一跳呢？举个例子，比如说<span class="jill"></span>F，F<span class="jill"></span>到<span class="jill"></span>A<span class="jill"></span>的上一跳是<span class="jill"></span>E，那么再查<span class="jill"></span>E，发现<span class="jill"></span>E<span class="jill"></span>到<span class="jill"></span>A<span class="jill"></span>的上一跳是<span class="jill"></span>D，而<span class="jill"></span>D<span class="jill"></span>与<span class="jill"></span>A<span class="jill"></span>相邻，所以<span class="jill"></span>A<span class="jill"></span>的路由表中去<span class="jill"></span>F<span class="jill"></span>的下一跳就是<span class="jill"></span>D<span class="jill"></span>了。这就是<span class="jill"></span>dijkstra<span class="jill"></span>算法建立路由表的步骤。路由表如下所示（路由表往往包含目的地和对应的下一跳，有时候会有链路成本）：</span></div></div><div id="8uhQkSXS8ysXAe8aQGP2Vz" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://img-blog.csdn.net/20180111121314271?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuemhlbjc1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style="width: 448px"/></figure></div><div id="75ELGrBojmtprkK8pkk84z" class="wolai-block wolai-text"><div><span class="inline-wrap">链路状态算法只计算和其相邻节点的信息，再更新。它测量与相邻节点的距离方法是：发送一个<span class="jill"></span>hello<span class="jill"></span>报文，周围节点接收到<span class="jill"></span>hello<span class="jill"></span>报文之后给出自己的地址返回给发送方表示我是你周围的临界点。发送方再发送<span class="jill"></span>echo<span class="jill"></span>报文，接收方收到<span class="jill"></span>echo<span class="jill"></span>立刻返回，根据时间戳就可以测出链路成本了。然后这个路由器就可以用相邻链路成本用<span class="jill"></span>LS<span class="jill"></span>算法计算自己的路由表信息。它的缺点是路由器来回震荡问题，但是健壮性比较好，不容易出现满收敛的问题，故障也不会广泛传播。</span></div></div><div id="xt5T6rmSMWrToZH4V6tBKX" class="wolai-block wolai-text"><div><span class="inline-wrap">以上就是最经典的两种路由算法。</span></div></div><div id="urMALhXqRzU8e5DE2wLkT6" class="wolai-block wolai-text"><div><span class="inline-wrap">拓展阅读</span></div></div><div id="pujWiVQoWr3WYqp26AU8xA" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="http://blog.csdn.net/hanzhen7541/article/details/79030748"><span>网络层的作用</span></a></span></div></div></article><footer></footer></body></html>