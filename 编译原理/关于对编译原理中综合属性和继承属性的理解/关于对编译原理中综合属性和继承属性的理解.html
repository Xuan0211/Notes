<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>关于对编译原理中综合属性和继承属性的理解 - 知乎 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="关于对编译原理中综合属性和继承属性的理解 - 知乎" class="main-title"></div></div></header><article><div id="v2uHWaVf5Tg64yAFz2ruA7" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>背景:</b></span></div></div><div id="fmgCVFp4xjdsHLH11TYavd" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>之前看书，也看到了对综合属性和继承属性，看了之后没什么感觉，这次有机会去实现一个带虚拟机的解释器，重新翻书，对有综合属性和继承属性的理解有了更加深刻的认识。写一篇文章做个记录</b></span></div></div><h2 id="5kWY1EgLNvZXixj3swb7ZG" class="wolai-block"><span class="inline-wrap">1:定义</span></h2><h3 id="x26ssB4FVSAiF6fQqgTKcB" class="wolai-block"><span class="inline-wrap">1.1<span class="jill"></span>属性:</span></h3><div id="4uKp3Sz1vYuyitemAejTfm" class="wolai-block wolai-text"><div><span class="inline-wrap">属性是附加在产生式中节点的语义定义。这个定义有点抽象，结合下面这个产生式，会有更好的理解：</span></div></div><code-block id="nK2a2y1zDaBRR5p3kVmowJ" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>E->E1+T           E.val:=E1.val+T.val</pre></div></code-block><div id="tC6USPEHHUqA9P7acEG1Uh" class="wolai-block wolai-text"><div><span class="inline-wrap">第一列是产生式，第二列是具体的语义定义。</span></div></div><div id="6mNiwDqAcUtJvSD57Dgm1y" class="wolai-block wolai-text"><div><span class="inline-wrap">这个产生式语义定义表示的是算法加法。(关于上面的语义定义我的理解：比如说 &#39;+&#39; 这个符号，可理解成字符串连接，也可以，理解成是算法加法，具体如何定义，就看语义规则是如何定义的。)</span></div></div><div id="o8zYWmGn9iTTyf9igSLNJG" class="wolai-block wolai-text"><div><span class="inline-wrap">E1.val，val<span class="jill"></span>就是<span class="jill"></span>E1<span class="jill"></span>的属性值</span></div></div><div id="a2MudnHsxWFY8qndwBVfw6" class="wolai-block wolai-text"><div><span class="inline-wrap">T.val ，val<span class="jill"></span>就是<span class="jill"></span>T.val<span class="jill"></span>的属性值</span></div></div><div id="5SoHYh7qGTQuzaokX2aZ3F" class="wolai-block wolai-text"><div><span class="inline-wrap">E.val ，val<span class="jill"></span>就是<span class="jill"></span>E.val<span class="jill"></span>的属性值</span></div></div><h3 id="9M2CAeGZ2mz3SVVfkTAw7B" class="wolai-block"><span class="inline-wrap">1.2<span class="jill"></span>综合属性:</span></h3><div id="F5rMrGatu3jTDYJGx9FN9" class="wolai-block wolai-text"><div><span class="inline-wrap">如下:</span></div></div><code-block id="rpgjqKiaF51Exva2P8LAAq" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>A→X1X2...Xn                              A.s=f(A.in,c1,c2,...,ck)
</pre></div></code-block><div id="sfi9ZYGE44iRau689Xin1i" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://pic3.zhimg.com/v2-04452fe6de164f8fd7d97d3b528208ba_b.jpg" style="width: 666.4px"/></figure></div><div id="6JcgWkuys3Pu7WEWTFEBJQ" class="wolai-block wolai-text"><div><span class="inline-wrap">如上图,A.s<span class="jill"></span>表示的是<span class="jill"></span>A<span class="jill"></span>的综合属性,</span><span class="inline-wrap"><a href="https://link.zhihu.com/?target=http%3A//A.in"><span>http://A.in</span></a></span><span class="inline-wrap">表示的是<span class="jill"></span>A<span class="jill"></span>的继承属性，函数<span class="jill"></span>f(</span><span class="inline-wrap"><a href="http://A.in"><span>A.in</span></a></span><span class="inline-wrap">,c1,c2,...,ck)是语义规则</span></div></div><div id="tRSFU7BtnWtLJckicVu8tr" class="wolai-block wolai-text"><div><span class="inline-wrap">公式 A.s=f(</span><span class="inline-wrap"><a href="http://A.in"><span>A.in</span></a></span><span class="inline-wrap">,c1,c2,...,ck)很清晰的表达了，A<span class="jill"></span>的综合属性，可以有自己的孩子节点 和自己的继承属性计算而得。</span></div></div><h3 id="rVK9y1PpRtei6JdJy1VU1N" class="wolai-block"><span class="inline-wrap">1.3<span class="jill"></span>继承属性</span></h3><div id="dHAEKC2yDMWLwEBz5zSg9e" class="wolai-block wolai-text"><div><span class="inline-wrap">如下：</span></div></div><code-block id="tKgcLnxGgbyVctAcrQTW75" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>A→X1X2...Xn           Xi.in=f(c,c1,c2,...,ck)
</pre></div></code-block><div id="aA56JTS5SHhdmDH36eb5nM" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://pic4.zhimg.com/v2-da611b577a1ced6960d1333c9d052ca7_b.jpg" style="width: 751.2px"/></figure></div><div id="7Mk4nDF69bS4UTX9a4ZqZ5" class="wolai-block wolai-text"><div><span class="inline-wrap">继承属性的计算，通过这个公式可以知道，Xi.in=f(c,c1,c2,...,ck) 是由父节点，和左侧的兄弟节点传递给<span class="jill"></span>Xi<span class="jill"></span>的（注意：不能是右侧的兄弟节点）</span></div></div><h3 id="iGhPKe6hnT81zAzT4zSxCP" class="wolai-block"><span class="inline-wrap">1.4 综合属性和继承属性的应用</span></h3><div id="bFVa2M3YCbjNc27AxsaEgk" class="wolai-block wolai-text"><div><span class="inline-wrap">这两种属性主要应用在<span class="jill"></span>L<span class="jill"></span>属性文法和<span class="jill"></span>S<span class="jill"></span>属性文法中。</span></div></div><div id="xqCgHLXNjSiMNAKSLWLjto" class="wolai-block wolai-text"><div><span class="inline-wrap">S-属性文法：只含有综合属性，某符号的综合属性值由自己继承属性和后代结点的属性值决定；</span></div></div><div id="nmcGD23FJQZotavKeWRhJF" class="wolai-block wolai-text"><div><span class="inline-wrap">L-属性文法：既含有综合属性又含有继承属性，且某文法符号的继承属性值由其左边结点和父结点的继承属性值决定；</span></div></div><div id="niNkKefV4LMa2nTraV9RA4" class="wolai-block wolai-text"><div><span class="inline-wrap">下面分别举一个例子要说明<span class="jill"></span>S-属性文法 和<span class="jill"></span>L<span class="jill"></span>属性文法。</span></div></div><div id="whRNJsJv72Y8vtfFt7DvNX" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>S-属性文法</b></span></div></div><div id="3FX5UbqWJSkKm92WGYgaVk" class="wolai-block wolai-text"><div><span class="inline-wrap">如下表格的文法属于<span class="jill"></span>S-属性文法(注：一个算术计算的文法)</span></div></div><div id="i5dfckLiRSSPDMNTzDavzg" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap">产生式</span></th><th style="width: 100px"><span class="inline-wrap">语义规则</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">L-&gt;E</span></td><td><span class="inline-wrap">Print(E.val)</span></td></tr><tr><td><span class="inline-wrap">E-&gt;E1+T</span></td><td><span class="inline-wrap">E.val:=E1.val+T.val</span></td></tr><tr><td><span class="inline-wrap">E-&gt;T</span></td><td><span class="inline-wrap">E.val:=T.val</span></td></tr><tr><td><span class="inline-wrap">T-&gt;T1*F</span></td><td><span class="inline-wrap">T.val:=T1.val *F.val</span></td></tr><tr><td><span class="inline-wrap">T-&gt;F</span></td><td><span class="inline-wrap">T.val:=F.val</span></td></tr><tr><td><span class="inline-wrap">F-&gt;(E)</span></td><td><span class="inline-wrap">F.val:=E.val</span></td></tr><tr><td><span class="inline-wrap">F-&gt;digit</span></td><td><span class="inline-wrap">F.val:=digit.lexval</span></td></tr></tbody></table></div><div id="28ZUYsSaUosAojVhEPXez8" class="wolai-block wolai-text"><div><span class="inline-wrap">通过上面的文法，可以发现以上文法计算的得到推导规则左侧的都是综合属性，即由叶子节点算出父节点的综合属性。</span></div></div><div id="b5UhXi4qfWSbiXeMbbGWoa" class="wolai-block wolai-text"><div><span class="inline-wrap">如 3＊5+4<span class="jill"></span>的语义规则的分析树如下：</span></div></div><div id="9L1rTE98uaSBbCHrYhNiUS" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://pic2.zhimg.com/v2-727cc20b68dbaa3aa4a92fac51061bc9_b.jpg" style="width: 576px"/></figure></div><div id="e6sTKwbqSPhMTWM5m6rEEG" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>L-属性文法</b></span></div></div><div id="do9gMiKWAr2VSRb15mVZx" class="wolai-block wolai-text"><div><span class="inline-wrap">如下表格的文法属于<span class="jill"></span>L-属性文法(注：一个语句声明的文法)</span></div></div><div id="ndASkqoXFrMD2ox9eeydcf" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap">产生式</span></th><th style="width: 100px"><span class="inline-wrap">语义规则</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">D→TL</span></td><td><span class="inline-wrap"><a href="http://L.in"><span>L.in</span></a></span><span class="inline-wrap">:=T.type</span></td></tr><tr><td><span class="inline-wrap">T→int</span></td><td><span class="inline-wrap">T.type=integer</span></td></tr><tr><td><span class="inline-wrap">T→real</span></td><td><span class="inline-wrap">T.type:=real</span></td></tr><tr><td><span class="inline-wrap">L→L1,id</span></td><td><span class="inline-wrap"><a href="http://L1.in"><span>L1.in</span></a></span><span class="inline-wrap">:=</span><span class="inline-wrap"><a href="https://link.zhihu.com/?target=http%3A//L.in"><span>http://L.in</span></a></span></td></tr><tr><td><span class="inline-wrap">addtype(id.entry,</span><span class="inline-wrap"><a href="https://link.zhihu.com/?target=http%3A//L.in"><span>http://L.in</span></a></span><span class="inline-wrap">)</span></td><td><span class="inline-wrap"></span><br/></td></tr><tr><td><span class="inline-wrap">L→id</span></td><td><span class="inline-wrap">addtype(id.entry,</span><span class="inline-wrap"><a href="https://link.zhihu.com/?target=http%3A//L.in"><span>http://L.in</span></a></span><span class="inline-wrap">)</span></td></tr></tbody></table></div><div id="jsp99KN81QSWdLm5RjJ7nG" class="wolai-block wolai-text"><div><span class="inline-wrap">如以下说明语句：real id1，id2，id3</span></div></div><div id="pjCY8uAaoJZN4jCtyuETkW" class="wolai-block"><figure class="wolai-center" style="width: 100%"><img src="https://pic1.zhimg.com/v2-6915d661ba188da071fdba6032ebbffc_b.jpg" style="width: 498.4px"/></figure></div><h2 id="sRp6tTrFx2F7XFFeFr6pFe" class="wolai-block"><span class="inline-wrap">2:深入的理解</span></h2><div id="8SnEntkWkpV1cMAyHrTFzt" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap"></span><br/></th><th style="width: 100px"><span class="inline-wrap">L<span class="jill"></span>属性文法</span></th><th style="width: 100px"><span class="inline-wrap">S<span class="jill"></span>属性文法</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">分析方法</span></td><td><span class="inline-wrap">自顶向下<span class="jill"></span>LL</span></td><td><span class="inline-wrap">自下向上<span class="jill"></span>LR</span></td></tr><tr><td><span class="inline-wrap">语义规则触发时机(重要)</span></td><td><span class="inline-wrap">任何文法符号的前后都有可能</span></td><td><span class="inline-wrap">归约到非终结符时</span></td></tr></tbody></table></div><div id="5Z6VRa8TCWtEsc7oXzXDHu" class="wolai-block wolai-text"><div><span class="inline-wrap">对于第二个区别（语义规则触发时机）L<span class="jill"></span>属性文法为什么要把语义属性往下传？因为自顶向下分析，他不知道后面是什么，什么时候可以推导成一个确定的非终结符，他一直在预测，把父亲节点，和左侧的兄弟节点，把东西往后面传.所以要在一个合适的时机，去对语义属性进行读写。S<span class="jill"></span>属性文法只有在规约的时候（其实是找到对应的句柄，左侧的第一个）才会执行语义规则，算出父亲节点的综合属性。</span></div></div><div id="gDNDoe68fVGookW8wSX78m" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>例子<span class="jill"></span>1:</b></span></div></div><div id="63cgCMwnGfgReAd6WoThJj" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 195px"><span class="inline-wrap">S<span class="jill"></span>属性文法</span></th><th style="width: 225px"><span class="inline-wrap">L<span class="jill"></span>属性文法</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">E→TR</span></td><td><span class="inline-wrap">E→TR</span></td></tr><tr><td><span class="inline-wrap">R→+TR ｛print(+)｝</span></td><td><span class="inline-wrap">R→+T{print(+)}R</span></td></tr><tr><td><span class="inline-wrap">R→-TR ｛print(-)｝</span></td><td><span class="inline-wrap">R→-T{print(-)}R</span></td></tr><tr><td><span class="inline-wrap">R→ε</span></td><td><span class="inline-wrap"></span><br/></td></tr><tr><td><span class="inline-wrap">T→num ｛print(num)｝</span></td><td><span class="inline-wrap">{print(num)}</span></td></tr></tbody></table></div><div id="qmXPwmJUTKzQPKr5b8Gf29" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>例子<span class="jill"></span>2(L<span class="jill"></span>属性文法):</b></span></div></div><code-block id="haGSKZSAvyu7hqzARXdVha" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>S→A1A2 {A1.in=1;A2.in=2}
A→a {print(A.in)}</pre></div></code-block><div id="7jUjkfTJZumP9AbEmsZoCg" class="wolai-block wolai-text"><div><span class="inline-wrap">上面这个<span class="jill"></span>L<span class="jill"></span>属性文法是有问题的文法，产生式右边的继承属性必须在这个符号以前计算出来。正确的应该如下：</span></div></div><code-block id="j6rAQu8HH2afRoGDYAGC6A" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>S→{A1.in=1}A1{A2.in=2}A2
A→a {print(A.in)}</pre></div></code-block><div id="75sxRa92We8kK9PQUsN3nk" class="wolai-block wolai-text"><div><span class="inline-wrap">L<span class="jill"></span>属性文不仅将语义属性关联到文法符号、将语义规则关联到产生式，而且还通过将语义动作嵌入到产生式的适当位置来表达该语义动作的执行时机</span></div></div><h2 id="jcKdcYKqdZ7NbCN9LwSsB3" class="wolai-block"><span class="inline-wrap">3:总结和启发</span></h2><h3 id="23eBXiHwiNdNp1bw3jNeyz" class="wolai-block"><span class="inline-wrap">3.1 算法通过文法来表述</span></h3><div id="2FDYU6qhTZF6sbyuDxSXxg" class="wolai-block wolai-text"><div><span class="inline-wrap">希望可以总结出从理论到工程化实践的方法，从工程化抽象到理论的方法。我这里只讨论第一种情况。例如对于一些难度比较大的算法题，我们是不是可以试图通过具体算法抽象成属性文法（把算法先抽象成一个属性文法的优点是：可以更直观更容易的去&quot;证明&quot;算法的正确性），然后再根据这个属性文法去编码实现。</span></div></div><div id="twHDenLFq2A5XYUDWvpSRq" class="wolai-block wolai-text"><div><span class="inline-wrap">所以一些算法题，就变成了先写文法，再去实现文法的套路。</span></div></div><div id="dj58zWsWXedxRPt9zeduLi" class="wolai-block wolai-text"><div><span class="inline-wrap">举个简单的例子</span></div></div><div id="m3Gc1eTK3Zy8VHejC386VX" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>题目<span class="jill"></span>1:写出将输入串的二进制转换成十进制整数的</b></span></div></div><div id="3sviF1DgvVMw9qJrmisqUY" class="wolai-block wolai-text"><div><span class="inline-wrap">上面这道题通过<span class="jill"></span>C++<span class="jill"></span>来写其实很简单，这里就不在阐述。但是其实也可以把这道算法题，转成文法来写，然后根据文法，写出具体的算法步骤。具体文法如下：</span></div></div><div id="4fJxQWm5YQ2TJ16YeWyJUs" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap">产生式</span></th><th style="width: 100px"><span class="inline-wrap">语义规则</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">S-&gt;L</span></td><td><span class="inline-wrap">{printf(L.a)}</span></td></tr><tr><td><span class="inline-wrap">L-&gt;L1B</span></td><td><span class="inline-wrap">{L.a=L1.a*2+B.a}</span></td></tr><tr><td><span class="inline-wrap">L-&gt;B</span></td><td><span class="inline-wrap">{L.a=B.a}</span></td></tr><tr><td><span class="inline-wrap">B-&gt;0</span></td><td><span class="inline-wrap">{B.a=0}</span></td></tr><tr><td><span class="inline-wrap">B-&gt;1</span></td><td><span class="inline-wrap">{B.a=1}</span></td></tr></tbody></table></div><div id="5P1m4wYDbp68mRNfgTCLTF" class="wolai-block wolai-text"><div><span class="inline-wrap">很显然这是一个<span class="jill"></span>S<span class="jill"></span>属性的文法，通过文法规则的语义解析，很容易做出这道题。</span></div></div><h3 id="i99Wkn2zaEcMXuNAM4tyto" class="wolai-block"><span class="inline-wrap">3.2<span class="jill"></span>编译器的实现</span></h3><div id="ohPd3pw7yt4YWSacCAkLS9" class="wolai-block wolai-text"><div><span class="inline-wrap">实现编译器的时候，是不是应该根据一个文法，先去把相关的属性文法先去实现掉？（LL<span class="jill"></span>的语法分析对应的是<span class="jill"></span>L<span class="jill"></span>属性文法，LR<span class="jill"></span>的语法分析对应的是<span class="jill"></span>S<span class="jill"></span>属性文法）然后根据属性文法再去写代码？这样能保证编译器执行的正确性和未来更轻松的进行编译的维护。</span></div></div><div id="dhLciMQ5nrKmph8cp85ViJ" class="wolai-block wolai-text"><div><span class="inline-wrap">对编译器感兴趣的小伙伴，可以知乎私信跟我沟通。</span></div></div></article><footer></footer></body></html>