# 1088 滑雪

| OJ   | POJ        |
| ---- | ---------- |
| 解题报告 |            |
| 时间   | 2022/11/16 |
| AC   | ☑          |
| 算法   | DP,搜索      |

Description

Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 &#x20;

1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。

Input

输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。

Output

输出最长区域的长度。

Sample Input

5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9

Sample Output

25

# 记忆化搜索

> DP 的本质近于搜索，因为 DP 实际上计算了所有子问题的最优解
>
> **只是 DP 舍去了搜索可能要做的重复工作，所以这就是为什么 DP 有时候 空间复杂度高**
>
> 对搜索，用数组保存返回值，确保其不做重复的工作，就是记忆化搜索
>
> 如果把 DP 的状态看成是 DFS 的参数，每个 DP 都能被改成一个记忆化搜索
>
> 记忆化搜索也能写成类似 DP 的东西
>
> **记忆化搜索擅长的方面是，当你只能写出转移方程而对阶段和状态的划分很苦恼的时候，使用记忆化搜索**，或者不知道题目怎么做了写个暴搜改成记忆化搜索

## EX：滑雪

<http://poj.org/problem?id=1088>

核心就是记忆化搜索

### 代码

```c++
#include <iostream>
#include <string.h>
using namespace std;
int R, C, mapp[110][110];
int dis[4][2] = { {1,0},{0,1},{-1,0},{0,-1} };
int dp[110][110];
int dfs(int i, int j)
{
    if (dp[i][j])//记忆化搜索核心
        return dp[i][j];//如果已经搜索过这个位置那么直接返回答案
    //如果没有，那么就需要递归查询四周的路径长度
    
    int ans = 0;
    for (int t = 0; t < 4; t++)
    {
        int xx, yy;
        xx = i + dis[t][0];
        yy = j + dis[t][1];
        if (mapp[i][j] > mapp[xx][yy])
        {
            ans = max(ans, dfs(xx, yy));//如果[i,j]高于[xx][yy]，那么转移
            //选出最长的那条路径
        }        
    }
    dp[i][j] = ans + 1;//最后统一+1
    return dp[i][j];
}
int main()
{
    cin >> R >> C;
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i <= R + 1; i++)
    {
        for (int j = 0; j <= C + 1; j++)
        {
            mapp[i][j] = 10010;
        }
    }
    for (int i = 1; i <= R; i++)
    {
        for (int j = 1; j <= C; j++)
        {
            cin >> mapp[i][j];
        }
    }
    int ans = 0;
    for (int i = 1; i <= R; i++)
    {
        for (int j = 1; j <= C; j++)
        {
            ans = max(ans, dfs(i, j));
            //要从每一个位置都尝试拓展，不然会少答案
        }
    }
    cout << ans;
    return 0;
}

```

### 测试

![](image/image_XmzwdkP9vv.png)

> ✒️POJ不接受万能头文件 裂开
>
> 一开始以为一定是从最高的点向下滑可以有最长路径，实际上从每一个点往下滑都有这个可能，是我憨了
