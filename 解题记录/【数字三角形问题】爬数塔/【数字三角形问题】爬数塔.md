# 【数字三角形问题】爬数塔

| OJ   | CSU        |
| ---- | ---------- |
| 解题报告 |            |
| 时间   | 2022/11/22 |
| AC   | ☑          |
| 算法   | DP         |

#### 题目描述

小南在CSU的某个角落发现了一座由数字组成的斜塔，他I想到塔顶去看看。小南可以从底层任意一个数字出发逐层爬上去，每次可以爬至上一层数字上或者上一层左边相邻的数字上（第1列只能爬至正上方上一层的数字上）。 &#x20;

7 &#x20;

3 8 &#x20;

8 1 0  &#x20;

2 7 4 4 &#x20;

4 5 2 6 5 &#x20;

如上图，小南如果从最下层也就是第5层的数字4向上爬，只能爬到上一层即第4层的2号数字上；如果从数字2爬，可以爬到其正上方的数字4上，也可以爬到数字7上；如果从最右边的数字5爬，则只能爬到其左上方的数字4上。 &#x20;

现在小南想知道，他从最下层开始爬到塔顶，如何选择爬上去的路径，使该路径经过的数字和最大？ &#x20;

#### 输入

多组测试数据。 &#x20;
每组测试数据的第一行是一个整数n（1≤n≤100）表示数塔的高度，接下来用n行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间\[0,99]内。 &#x20;

#### 输出

对于每个组测试数据，输出一个整数表示得到的最大和，每个输出占一行。

#### 样例输入&#x20;

5
7
3 8
8 1 0&#x20;
2 7 4 4
4 5 2 6 5

#### 样例输出&#x20;

30

## 解题思路

用二维数组存放数字三角形。
dp( r, j) : 第r行第 j 个数字(r,j从1 开始算)
MaxSum(r, j) : 从dp(r,j)到底边的各条路径中，最佳路径的数字之和。
问题：求 MaxSum(1,1)
典型的递归问题。
dp(r, j)出发，下一步只能走dp(r+1,j)或者dp(r+1, j+1)。故对于N行的三角形：

```c++
if ( r == N)

  MaxSum(r,j) = dp(r,j)

else

  MaxSum( r, j) = Max{ MaxSum(r＋1,j), MaxSum(r+1,j+1) } + dp(r,j)
```

## 算法优化：滚动数组

## 代码

```c
int main()
{
  int n;
  while (scanf("%d", &n) != EOF)
  {
    //咋说呢 感觉这个算法可以滚动优化
    int dp[100];
    memset(dp, 0, sizeof(dp));
    int maxx = 0;
    for (int i = 1; i <= n; i++)
    {
      for (int j = i; j >= 1; j--)
      {
        int t;
        scanf("%d", &t);
        dp[j] = mymax(dp[j], dp[j - 1]) + t;
        if (i == n)
        {
          maxx = mymax(dp[j], maxx);
        }
      }
    }
    printf("%d\n", maxx);
  }
  return 0;
}
```
