<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>分支限界法 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="分支限界法" class="main-title"></div></div></header><article><h1 id="nfGrf3B8tpuPRYBTY5CpG5" class="wolai-block"><span class="inline-wrap">分支限界法</span></h1><div id="cgHZ5gtVyyuB76fWcQUf3E" class="wolai-block wolai-text"><div><span class="inline-wrap">基于回溯法被提出</span></div></div><h2 id="jVXWSciWFPDCAJsEHNY6kb" class="wolai-block"><span class="inline-wrap">FIFO<span class="jill"></span>搜索</span></h2><aside id="rGWoWMavEX3TmvEgDtwQct" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">听起来有点像<span class="jill"></span>SPFA？</span></aside><h3 id="xALspNHH9t6dbA1fyEUais" class="wolai-block"><span class="inline-wrap">N<span class="jill"></span>皇后问题</span></h3><div id="fxW1BaMmThK5hpGLPRVuSa" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="oHAiZ7hJPq6ygqoTCEZZFH" class="wolai-block"><span class="inline-wrap">LC<span class="jill"></span>检索</span></h2><blockquote id="gEfoYczxSqWjLH2QbxomZt" class="wolai-block"><span class="inline-wrap">采用有效的方式选择<span class="jill"></span>E-结点进行拓展</span></blockquote><div id="2hMv8LYuQqVxW4guus45zW" class="wolai-block wolai-text"><div><span class="inline-wrap">优先队列式搜索</span></div></div><div id="sDMFVnV9h4BpC1gV5WaWe6" class="wolai-block wolai-text"><div><span class="inline-wrap">对每一个结点计算一个优先级</span></div></div><div id="fLdHQ5iHrdkyMRaLrqqeDg" class="wolai-block wolai-text"><div><span class="inline-wrap">或者说，做某种排序，使可以导致答案结点的活结点排在前面</span></div></div><h3 id="uT4LgnMp1G8V48DiApuC7C" class="wolai-block"><span class="inline-wrap">优先级</span></h3><aside id="sAbaMrHJ1uUJVqndSRMMq3" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">成本越小越优先 </span></aside><ol class="wolai-block"><li id="pSDBdnG7hJ74BzAT7wCoSQ"><div class="marker"></div><span class="inline-wrap">生成一个答案结点之前 子树<span class="jill"></span>X<span class="jill"></span>需要生成的结点数</span></li><li id="nFBeYvfMFaVu5u8sB5XB9r"><div class="marker"></div><span class="inline-wrap">在子树<span class="jill"></span>X<span class="jill"></span>中离<span class="jill"></span>X<span class="jill"></span>最近的那个答案结点到<span class="jill"></span>X<span class="jill"></span>的路径长度</span></li></ol><aside id="3iWtViLw7SM6mquLexAd9A" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">但是显然着并不好求的，因为答案结点是未知的</span></aside><h3 id="gYQFrZ4yLSX4tgM6kTVEvc" class="wolai-block"><span class="inline-wrap">结点成本函数</span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C(X)=g(X)+h(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></h3><h4 id="hpsXg9MvUY9uEPzfjf12Yk" class="wolai-block"><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span><span class="inline-wrap">（这是一个估算值）</span></h4><div id="mCieAd3EnKQuDoUAZAcU5S" class="wolai-block wolai-text"><div><span class="inline-wrap">是由<span class="jill"></span>X<span class="jill"></span>到达一个答案结点所需成本</span></div><aside id="oW3EARrLwbeauaTJrak11J" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">单纯使用<span class="jill"></span>g(X)会导致算法偏向纵深检查？</span></aside></div><h4 id="v8X1r8cMpyZcu31W5jpfhb" class="wolai-block"><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(X) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></span></h4><div id="oRsPdcZefcckt44JVKrUzz" class="wolai-block wolai-text"><div><span class="inline-wrap">根结点到结点<span class="jill"></span>X<span class="jill"></span>的成本</span></div></div><h2 id="bhyes1FiDUo9gXA977fhat" class="wolai-block"><span class="inline-wrap">华容道问题</span></h2><h3 id="2QMeK7XZyCuZ7vNV4RGUFL" class="wolai-block"><span class="inline-wrap">如何判断目标状态是否可以达到</span></h3><ol class="wolai-block"><li id="wZtQ75bhvHW8yc2k6DY8ex"><div class="marker"></div><span class="inline-wrap">编号</span></li><li id="2cUK5tE61BWNwupWcKKAwj"><div class="marker"></div><span class="inline-wrap">POSITION（16）表示空格位置</span></li><li id="ucP4CKALm6oQi3kokB76CC"><div class="marker"></div><span class="inline-wrap">LESS(i) 逆序数 </span></li><li id="fmpew7U5n7mdSNX4P7hkx"><div class="marker"></div><span class="inline-wrap">引入奇偶剪枝？</span></li></ol><h3 id="dUydqZfN7yKdmMKyU28YEQ" class="wolai-block"><span class="inline-wrap">状态空间树</span></h3><aside id="bc3PN8AfxgvgxW9n9U2TvG" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">移动牌和移动空格是等效的</span><div id="fppWKfs8kHVXPDfhuD3TAc" class="wolai-block wolai-text"><div><span class="inline-wrap">所以把问题转化成移动空格</span></div></div></aside><h3 id="9RzecG6tW4i9rt3rhvCxsL" class="wolai-block"><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mtext>（</mtext><mi>X</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">C（X）
 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">）</span></span></span></span></span></h3><div id="eCQ7wG993EYXL7r4AohcSr" class="wolai-block wolai-text"><div><span class="inline-wrap">当前位置到答案位置有几个位置不一样</span></div></div><h2 id="a1T6V17LTeBW629ZHncBZ3" class="wolai-block"><span class="inline-wrap">01<span class="jill"></span>背包</span></h2><h3 id="7SnJTgqSq75MpG7YeVio6P" class="wolai-block"><span class="inline-wrap">队列式分支限界</span></h3><h3 id="bNfPNLHxXtez3pyGNqX7iM" class="wolai-block"><span class="inline-wrap"></span><br/></h3><div id="pDHdzMii4ZYTfPKpZfF4FH" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="6icgJPD1g2SRSRjT2eFaS3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h2 id="7H5vJpKiGs9yMNjSq4J13P" class="wolai-block"><span class="inline-wrap">基本思想</span></h2><h3 id="4PYwvxW6hBCHM2UByXaHMt" class="wolai-block"><span class="inline-wrap">每一个`活结点` 只有一次机会成为拓展结点</span></h3><h3 id="pDYHK2NXBVY95rEBvgZ7gq" class="wolai-block"><span class="inline-wrap">活结点一旦成为拓展结点 就一次性产生所有儿子结点</span></h3><div id="3e5XnbmfurGUEzYfiT8KfW" class="wolai-block wolai-text"><div><span class="inline-wrap">其中明显不可能的应该被舍弃</span></div></div><h2 id="kGDWWBULGWRGVT5DpkBU2P" class="wolai-block"><span class="inline-wrap">两种典型的解空间树</span></h2><h3 id="jzMcZh9izLUDs6cJV9JgKr" class="wolai-block"><span class="inline-wrap">子集树</span></h3><h3 id="8RSWaADn4ctw6EGfmbxNai" class="wolai-block"><span class="inline-wrap">排列树</span></h3><h2 id="c2EogrVxv32WwdY9P2AvqG" class="wolai-block"><span class="inline-wrap">适用范围</span></h2><div id="74hTaha2SBKfxT3m3qSnKs" class="wolai-block wolai-text"><div><span class="inline-wrap">对比回溯法（DFS）</span></div></div><div id="k1mJsMmoZwT9Yc3yuG975p" class="wolai-block wolai-text"><div><span class="inline-wrap">只能找到一个解/某种意义上的最优解</span></div></div><h4 id="c3ouxtSzA8yhnMJJggsQEN" class="wolai-block"><span class="inline-wrap">更适合用回溯法解决的问题：N<span class="jill"></span>皇后问题</span></h4><div id="dVposRkCV2LxUB8geXZUJB" class="wolai-block wolai-text"><div><span class="inline-wrap">是一颗排列树</span></div></div><h4 id="hoW4TUScjaXds7ZxUFeZgg" class="wolai-block"><span class="inline-wrap">都可以解决的问题：01<span class="jill"></span>背包问题</span></h4><div id="6zztAbFZYDNjBG1N4Sx13t" class="wolai-block wolai-text"><div><span class="inline-wrap">是一颗子集树</span></div></div><div id="uZoByY6tmkUmNEZgR3Q2Mu" class="wolai-block wolai-text"><div><span class="inline-wrap">如果采用回溯法：</span></div></div><div id="vzBZAdfG8kCEyghGu5orgA" class="wolai-block wolai-text"><div><span class="inline-wrap">可以构造一个上界函数，来剪枝</span></div></div><h2 id="ou9qSBenhqiE88QmVNwssn" class="wolai-block"><span class="inline-wrap">设计思路</span></h2><div id="vdHSTfm2asNk1zm99qHP4k" class="wolai-block wolai-text"><div><span class="inline-wrap">根据限界函数估算目标函数的界 并用来剪枝需要加入的儿子</span></div></div><aside id="fn8ceVM6JiGLJGtNiBEACr" class="bg-cultured wolai-block"><div data-symbol="✒️" class="icon"></div><span class="inline-wrap">也就是极端法剪枝</span></aside><h2 id="oAornmucCrbygS3LyEY9qm" class="wolai-block"><span class="inline-wrap">关键问题</span></h2><h3 id="cLkqHkPpUZmGjUKRJ23ZXx" class="wolai-block"><span class="inline-wrap">⭐️如何确定合适的限界函数</span></h3><h3 id="492gfC8ALK86UwTDd3EFzF" class="wolai-block"><span class="inline-wrap">如何组织待处理的结点表</span></h3><h3 id="2HXwmL7Ef3SvYgMnLv7V34" class="wolai-block"><span class="inline-wrap">如何确定最优解中的各个分量</span></h3><h2 id="5Atp1xwfSU6MdvziVjFrRF" class="wolai-block"><span class="inline-wrap">时间性能</span></h2><div id="cCemZgnweQDwqQ7NWB5QBr" class="wolai-block wolai-text"><div><span class="inline-wrap">实际上都属于暴力法：所以最坏情况就是暴力</span></div></div><div id="9dz4DXVPd3AGomv3vHbcrV" class="wolai-block wolai-text"><div><span class="inline-wrap"> </span><br/></div></div><h1 id="6iWGmetkCJ7pFst1ajoA9B" class="wolai-block"><span class="inline-wrap">搜索</span></h1><h2 id="jCpyFUV6NtsnkvG1C7KKFj" class="wolai-block"><span class="inline-wrap">摸论（回溯法）DFS</span></h2><h2 id="GiqCjWcGAiwoqRRTxjxnf" class="wolai-block"><span class="inline-wrap">BFS D—DFS</span></h2><div id="rsHeKUHTESLQJ5xogA4PQR" class="wolai-block wolai-text"><div><span class="inline-wrap">状态空间的搜索实际上是一种树/DAG<span class="jill"></span>的搜索</span></div></div><div id="dxS2hTbkhiZHAQFu8eRqzG" class="wolai-block wolai-text"><div><span class="inline-wrap"> （树是没有环的）</span></div></div><h2 id="6H4wan5MiVEVvRQBstKh9K" class="wolai-block"><span class="inline-wrap">广搜</span></h2><h2 id="w5w5yUQKXc5ieph8DoBhpT" class="wolai-block"><span class="inline-wrap">深搜</span></h2><h2 id="qS5mhMKRkoc9a8euoDuNpL" class="wolai-block"><span class="inline-wrap">启发式搜索</span></h2><div id="85ni8YvjT9aWdFpKY1Dr9i" class="wolai-block wolai-text"><div><span class="inline-wrap">相对于<span class="jill"></span>DFS<span class="jill"></span>和<span class="jill"></span>BFS 启发式搜索是可以跳跃的</span></div></div><h3 id="fXVnLbPq9Yd7bPRTMqvMNc" class="wolai-block"><span class="inline-wrap">禁忌搜索<span class="jill"></span>Tabu Search</span></h3><h4 id="xv7Dz6zqXE4TpN9LBvixEq" class="wolai-block"><span class="inline-wrap">禁忌表</span></h4><h4 id="u6Hfhc3FdJzjXFqrvqegVh" class="wolai-block"><span class="inline-wrap">禁忌长度</span></h4><div id="2iMa5pRmXrE2muypv6jDx" class="wolai-block wolai-text"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n!)=O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">!)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></div><div id="dAcEwRH9muEFj7AqgFANLR" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="w6oDBT5idksi5NzPaM1YtR" class="wolai-block wolai-simple-table"><table><tbody><tr><td style="width: 100px"><span class="inline-wrap"></span><br/></td><td style="width: 100px"><span class="inline-wrap">优点</span></td><td style="width: 100px"><span class="inline-wrap">缺点</span></td></tr><tr><td style="width: 100px"><span class="inline-wrap">DFS / BFS</span></td><td style="width: 100px"><span class="inline-wrap"></span><br/></td><td style="width: 100px"><span class="inline-wrap"></span><br/></td></tr><tr><td style="width: 100px"><span class="inline-wrap">启发式搜索</span></td><td style="width: 100px"><span class="inline-wrap"></span><br/></td><td style="width: 100px"><span class="inline-wrap"></span><br/></td></tr><tr><td style="width: 100px"><span class="inline-wrap"></span><br/></td><td style="width: 100px"><span class="inline-wrap"></span><br/></td><td style="width: 100px"><span class="inline-wrap"></span><br/></td></tr></tbody></table></div><div id="3nqMdCXBTf1p6nb4NxrBrJ" class="wolai-block wolai-text"><div><span class="inline-wrap">关于启发函数的寻找，我们已经知道一个启发函数设置的好坏直接影响搜索算法的最优性与否。启发函数永远不是唯一的，最好的启发函数当然是和实际耗散相等，但是随便一设置就是实际值的话这种概率还是蛮小的，这里不讨论，下面介绍一种常用的寻找启发函数的方法，即由松弛问题得到启发函数，这种方法得出的启发函数通常都是能用的，只不过具体对算法有多大的优化那就还是要看具体怎么设置了。这种方法说起来其实很简单，就是我们将目标松弛化，然后得到启发函数值。就比如说从<span class="jill"></span>A<span class="jill"></span>到<span class="jill"></span>B<span class="jill"></span>实际距离是<span class="jill"></span>50<span class="jill"></span>公里，这<span class="jill"></span>50<span class="jill"></span>公里可能是因为道路的曲折、然后障碍物之类的一些影响，导致从<span class="jill"></span>A<span class="jill"></span>到<span class="jill"></span>B<span class="jill"></span>需要<span class="jill"></span>50<span class="jill"></span>公里，但是如果我们将这个问题松弛化，就是完全忽略道路的曲折，还有路上的障碍物等等一系列因素，那么得到<span class="jill"></span>A<span class="jill"></span>到<span class="jill"></span>B<span class="jill"></span>的直线距离可能就是<span class="jill"></span>30<span class="jill"></span>公里，那么这个<span class="jill"></span>30<span class="jill"></span>公里就可以用来做启发函数，也就是说告诉计算机这么一个约束条件，A<span class="jill"></span>到<span class="jill"></span>B<span class="jill"></span>至少有<span class="jill"></span>30<span class="jill"></span>公里，小于这个值的路径一律不予考虑，因为这已经是最宽松的条件了。</span></div></div><div id="iaLomgHfT4gtTWakHu6t7y" class="wolai-block wolai-text"><div><span class="inline-wrap">再比如说这个数码游戏，正常情况下每一步都只有那么少数的几个数字能够移动，且不可能斜着移动，也不能覆盖。如果我们将这些规则都忽略，也就是说将这个问题松弛化，得出从起始位置到最终位置需要<span class="jill"></span>8<span class="jill"></span>步，那么设置这个<span class="jill"></span>8<span class="jill"></span>步为启发函数的话显然就是正确的，因为至少需要<span class="jill"></span>8<span class="jill"></span>步这是显然的。这种将问题进行松弛化然后再取启发函数的方法就是非常常用的方法，可能具体优化程度取决于松弛程度，但是得到的启发函数正常情况下时一定能用的。</span></div></div><div id="eho7cLNEt6A3JEwaWfvW6e" class="wolai-block wolai-text"><p><br/></p></div><div id="aD6DgHVQiyNcAJUAQ5QGm5" class="wolai-block wolai-text"><p><br/></p></div><h1 id="iTuxidstvvKLMzQd427ej9" class="wolai-block"><span class="inline-wrap">剪枝</span></h1><h2 id="rWRtsnuKtTiEtg7Vb95EZF" class="wolai-block"><span class="inline-wrap">原则</span></h2><h3 id="fGn4VrwTDAHqK5q1G9teEB" class="wolai-block"><span class="inline-wrap">正确性</span></h3><h3 id="3ArXswnkg9nKsYpj1JMzEr" class="wolai-block"><span class="inline-wrap">准确性</span></h3><h3 id="fgEK1mwbu9DDgWU9EJNrA1" class="wolai-block"><span class="inline-wrap">高效性</span></h3><h2 id="sctCybmuVbpzt4vScza6SY" class="wolai-block"><span class="inline-wrap">分类</span></h2><h3 id="gbUSiFZiWXLW9FMJdiPWue" class="wolai-block"><span class="inline-wrap">可行性剪枝</span></h3><h3 id="i5edgzxZve7obbi6XB3m5h" class="wolai-block"><span class="inline-wrap">最优性剪枝</span></h3><h4 id="9BdkQtHM9bydWnoDWyu4tj" class="wolai-block"><span class="inline-wrap">上下界剪枝</span></h4><h2 id="7534k6QVk1aPoAN5XoYnHX" class="wolai-block"><span class="inline-wrap">方法</span></h2><h3 id="oS5cPJATxmvy6ERCtFsrUj" class="wolai-block"><span class="inline-wrap">极端法</span></h3><div id="9GLqnVNE3p1Mk62FVpzM8H" class="wolai-block wolai-text"><div><span class="inline-wrap">如果从当前节点出发，最理想的答案都比之前搜到的答案查，就不用继续搜索了</span></div></div><h3 id="3tmPXLZFQBCJCCDSJ9E7CA" class="wolai-block"><span class="inline-wrap">调整法</span></h3><h3 id="iFhKxJW5U6jktdDAmEuktp" class="wolai-block"><span class="inline-wrap">数学方法</span></h3><h4 id="94oXEB31sH73w6ay9dYC9X" class="wolai-block"><span class="inline-wrap">图：联通分量 </span></h4><div id="mpVvZs2z1Z7vjvJkbfQfmQ" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></article><footer></footer></body></html>